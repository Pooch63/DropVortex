"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_OUT_FILE_EXTENSION: function DEFAULT_OUT_FILE_EXTENSION1() {
        return DEFAULT_OUT_FILE_EXTENSION;
    },
    default: function _default() {
        return parserArgs;
    },
    initProgram: function initProgram1() {
        return initProgram;
    }
});
var _commander = /*#__PURE__*/ _interop_require_default(require("commander"));
var _core = require("@swc/core");
var _fs = require("fs");
var _path = require("path");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var DEFAULT_EXTENSIONS = [
    ".js",
    ".jsx",
    ".es6",
    ".es",
    ".mjs",
    ".ts",
    ".tsx",
    ".cts",
    ".mts"
];
var pkg = require("../../package.json");
var program;
var DEFAULT_OUT_FILE_EXTENSION = "js";
var initProgram = function() {
    program = new _commander.default.Command();
    /* istanbul ignore next */ if (process.env.NODE_ENV === "test") {
        program.exitOverride();
    }
    program.option("-f, --filename [filename]", "filename to use when reading from stdin - this will be used in source-maps, errors etc");
    program.option("--config-file [path]", "Path to a .swcrc file to use");
    program.option("--cli-config-file [path]", "Path to a JSON file containing CLI options. " + "Options provided directly via command line override the ones in the configuration file.");
    program.option("--env-name [name]", "The name of the 'env' to use when loading configs and plugins. " + "Defaults to the value of SWC_ENV, or else NODE_ENV, or else 'development'.");
    program.option("--no-swcrc", "Whether or not to look up .swcrc files");
    program.option("--delete-dir-on-start", "Whether or not delete output directory on start");
    program.option("--ignore [list]", "list of glob paths to **not** compile", collect);
    program.option("--only [list]", "list of glob paths to **only** compile", collect);
    program.option("-w, --watch", "Recompile files on changes");
    program.option("-q, --quiet", "Suppress compilation output");
    program.option("-s, --source-maps [true|false|inline|both]", "generate source maps", unstringify);
    program.option("--source-map-target [string]", "set `file` on returned source map");
    program.option("--source-file-name [string]", "set `sources[0]` on returned source map");
    program.option("--source-root [filename]", "the root from which all sources are relative");
    program.option("-o, --out-file [out]", "Compile all input files into a single file");
    program.option("-d, --out-dir [out]", "Compile an input directory of modules into an output directory");
    program.option("--out-file-extension [string]", "Use a specific extension for the output files [default: js]", DEFAULT_OUT_FILE_EXTENSION);
    program.option("-D, --copy-files", "When compiling a directory copy over non-compilable files");
    program.option("--strip-leading-paths", "Remove the leading directory (including all parent relative paths) when building the final output path", false);
    program.option("--include-dotfiles", "Include dotfiles when compiling and copying non-compilable files");
    program.option("-C, --config <config>", "Override a config from .swcrc file. e.g. -C module.type=amd -C module.moduleId=hello", collect);
    program.option("--sync", "Invoke swc synchronously. Useful for debugging.", collect);
    program.option("--workers [number]", "The number of workers to use for parallel processing");
    program.option("--log-watch-compilation", "Log a message when a watched file is successfully compiled", true);
    program.option("--extensions [list]", "Use specific extensions", collect);
    program.version("\n@swc/cli: ".concat(pkg.version, "\n@swc/core: ").concat(_core.version, "\n"));
    program.usage("[options] <files ...>");
    program.addHelpText("beforeAll", "\n============================================================================================\nBeta version of @swc/cli is now available via 'swcx' command.\nThis'll be a default command for @swc/cli@1.\nPlease give it a try and report any issues at https://github.com/swc-project/swc/issues/4017\n============================================================================================\n\n");
};
function unstringify(val) {
    try {
        return JSON.parse(val);
    } catch (e) {
        return val;
    }
}
function loadCLIConfigFile(program, opts, path) {
    var configOpts;
    var contents;
    // Parse the JSON file
    try {
        contents = (0, _fs.readFileSync)((0, _path.resolve)(process.cwd(), path), "utf-8");
    } catch (e) {
        throw new Error('Cannot read CLI config file "'.concat(path, '".'));
    }
    try {
        configOpts = JSON.parse(contents);
    } catch (e) {
        throw new Error('CLI config file "'.concat(path, '" is not a well-formed JSON file.'));
    }
    // Convert kebab case options in camel case one
    configOpts = Object.fromEntries(Object.entries(configOpts).map(function(param) {
        var _param = _sliced_to_array(param, 2), key = _param[0], value = _param[1];
        var camelCaseKey = key.replace(/(-[-a-z])/g, function(_, m) {
            return m.substring(1).toUpperCase();
        });
        return [
            camelCaseKey,
            value
        ];
    }));
    // Split existing options in default and provided one
    var defaults = [];
    var provided = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(opts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var pair = _step.value;
            if (program.getOptionValueSource(pair[0]) === "default") {
                defaults.push(pair);
            } else {
                provided.push(pair);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    // Merge options back with right priority
    return _object_spread({}, Object.fromEntries(defaults), configOpts, Object.fromEntries(provided));
}
function verifyArgsErrors(errors) {
    if (errors.length) {
        console.error("swc:");
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var error = _step.value;
                console.error("  " + error);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        process.exit(2);
    }
}
function collect(value, previousValue) {
    // If the user passed the option with no value, like "babel file.js --presets", do nothing.
    /* istanbul ignore next */ if (typeof value !== "string") return previousValue;
    var values = value.split(",");
    return previousValue ? previousValue.concat(values) : values;
}
function parserArgs(args) {
    program.parse(args);
    var opts = program.opts();
    if (opts.cliConfigFile) {
        try {
            opts = loadCLIConfigFile(program, opts, opts.cliConfigFile);
        } catch (e) {
            verifyArgsErrors([
                e.message
            ]);
            return;
        }
    }
    var filenames = program.args;
    var errors = [];
    if (opts.outDir && !filenames.length) {
        errors.push("--out-dir requires filenames");
    }
    if (opts.outFile && opts.outDir) {
        errors.push("--out-file and --out-dir cannot be used together");
    }
    if (opts.watch) {
        if (!opts.outFile && !opts.outDir) {
            errors.push("--watch requires --out-file or --out-dir");
        }
        if (!filenames.length) {
            errors.push("--watch requires filenames");
        }
    }
    if (!opts.outDir && filenames.length === 0 && typeof opts.filename !== "string" && opts.swcrc !== false) {
        errors.push("stdin compilation requires either -f/--filename [filename] or --no-swcrc");
    }
    var workers;
    if (opts.workers != null) {
        workers = parseFloat(opts.workers);
        if (!Number.isInteger(workers) || workers < 0) {
            errors.push("--workers must be a positive integer (found " + opts.workers + ")");
        }
    }
    verifyArgsErrors(errors);
    var swcOptions = {
        jsc: {
            parser: undefined,
            transform: {}
        },
        sourceFileName: opts.sourceFileName,
        sourceRoot: opts.sourceRoot,
        configFile: opts.configFile,
        swcrc: opts.swcrc
    };
    if (opts.sourceMaps !== undefined) {
        swcOptions.sourceMaps = opts.sourceMaps;
    }
    if (opts.config) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = opts.config[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var cfg = _step.value;
                var i = cfg.indexOf("=");
                var key = void 0;
                var value = void 0;
                if (i === -1) {
                    key = cfg;
                    value = true;
                } else {
                    key = cfg.substring(0, i);
                    value = unstringify(cfg.substring(i + 1));
                }
                // https://github.com/swc-project/cli/issues/45
                var options = swcOptions;
                var keyParts = key.split(".");
                var lastIndex = keyParts.length - 1;
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = keyParts.entries()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var _step_value = _sliced_to_array(_step1.value, 2), index = _step_value[0], keyPart = _step_value[1];
                        if (options[keyPart] === undefined && index !== lastIndex) {
                            options[keyPart] = {};
                        }
                        if (index === lastIndex) {
                            options[keyPart] = value;
                        } else {
                            options = options[keyPart];
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    var cliOptions = {
        outDir: opts.outDir,
        outFile: opts.outFile,
        stripLeadingPaths: Boolean(opts.stripLeadingPaths),
        filename: opts.filename,
        filenames: filenames,
        sync: !!opts.sync,
        workers: workers,
        sourceMapTarget: opts.sourceMapTarget,
        extensions: opts.extensions || DEFAULT_EXTENSIONS,
        watch: !!opts.watch,
        copyFiles: !!opts.copyFiles,
        outFileExtension: opts.outFileExtension || DEFAULT_OUT_FILE_EXTENSION,
        includeDotfiles: !!opts.includeDotfiles,
        deleteDirOnStart: Boolean(opts.deleteDirOnStart),
        quiet: !!opts.quiet,
        only: opts.only || [],
        ignore: opts.ignore || []
    };
    return {
        swcOptions: swcOptions,
        cliOptions: cliOptions
    };
} //# sourceMappingURL=options.js.map
