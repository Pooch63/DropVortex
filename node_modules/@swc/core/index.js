"use strict";
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function get() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return _instanceof(value, P) ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DEFAULT_EXTENSIONS = exports.getBinaryMetadata = exports.__experimental_registerGlobalTraceConfig = exports.minifySync = exports.minify = exports.bundle = exports.transformFileSync = exports.transformFile = exports.transformSync = exports.transform = exports.printSync = exports.print = exports.parseFileSync = exports.parseFile = exports.parseSync = exports.parse = exports.Compiler = exports.plugins = exports.version = void 0;
var path_1 = require("path");
var spack_1 = require("./spack");
var assert = __importStar(require("assert"));
// Allow overrides to the location of the .node binding file
var bindingsOverride = process.env["SWC_BINARY_PATH"];
// `@swc/core` includes d.ts for the `@swc/wasm` to provide typed fallback bindings
// todo: fix package.json scripts
var fallbackBindings;
var bindings = function() {
    var binding;
    try {
        binding = !!bindingsOverride ? require((0, path_1.resolve)(bindingsOverride)) : require("./binding.js");
        // If native binding loaded successfully, it should return proper target triple constant.
        var triple = binding.getTargetTriple();
        assert.ok(triple, "Failed to read target triple from native binary.");
        return binding;
    } catch (_) {
        // postinstall supposed to install `@swc/wasm` already
        fallbackBindings = require("@swc/wasm");
    } finally{
        return binding;
    }
}();
/**
 * Version of the swc binding.
 */ exports.version = require("./package.json").version;
/**
 * @deprecated JavaScript API is deprecated. Please use Wasm plugin instead.
 */ function plugins(ps) {
    return function(mod) {
        var m = mod;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = ps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var p = _step.value;
                m = p(m);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return m;
    };
}
exports.plugins = plugins;
var Compiler = /*#__PURE__*/ function() {
    function Compiler() {
        _class_call_check(this, Compiler);
        this.fallbackBindingsPluginWarningDisplayed = false;
    }
    _create_class(Compiler, [
        {
            key: "minify",
            value: function minify(src, opts) {
                return __awaiter(this, void 0, void 0, function() {
                    return _ts_generator(this, function(_state) {
                        if (bindings) {
                            return [
                                2,
                                bindings.minify(toBuffer(src), toBuffer(opts !== null && opts !== void 0 ? opts : {}))
                            ];
                        } else if (fallbackBindings) {
                            return [
                                2,
                                fallbackBindings.minify(src, opts)
                            ];
                        }
                        throw new Error("Bindings not found.");
                    });
                });
            }
        },
        {
            key: "minifySync",
            value: function minifySync(src, opts) {
                if (bindings) {
                    return bindings.minifySync(toBuffer(src), toBuffer(opts !== null && opts !== void 0 ? opts : {}));
                } else if (fallbackBindings) {
                    return fallbackBindings.minifySync(src, opts);
                }
                throw new Error("Bindings not found.");
            }
        },
        {
            key: "parse",
            value: function parse(src, options, filename) {
                return __awaiter(this, void 0, void 0, function() {
                    var res;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                options = options || {
                                    syntax: "ecmascript"
                                };
                                options.syntax = options.syntax || "ecmascript";
                                if (!bindings && !!fallbackBindings) {
                                    throw new Error("Fallback bindings does not support this interface yet.");
                                } else if (!bindings) {
                                    throw new Error("Bindings not found.");
                                }
                                if (!bindings) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    bindings.parse(src, toBuffer(options), filename)
                                ];
                            case 1:
                                res = _state.sent();
                                return [
                                    2,
                                    JSON.parse(res)
                                ];
                            case 2:
                                if (fallbackBindings) {
                                    return [
                                        2,
                                        fallbackBindings.parse(src, options)
                                    ];
                                }
                                _state.label = 3;
                            case 3:
                                throw new Error("Bindings not found.");
                        }
                    });
                });
            }
        },
        {
            key: "parseSync",
            value: function parseSync(src, options, filename) {
                options = options || {
                    syntax: "ecmascript"
                };
                options.syntax = options.syntax || "ecmascript";
                if (bindings) {
                    return JSON.parse(bindings.parseSync(src, toBuffer(options), filename));
                } else if (fallbackBindings) {
                    return fallbackBindings.parseSync(src, options);
                }
                throw new Error("Bindings not found.");
            }
        },
        {
            key: "parseFile",
            value: function parseFile(path, options) {
                return __awaiter(this, void 0, void 0, function() {
                    var res;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                options = options || {
                                    syntax: "ecmascript"
                                };
                                options.syntax = options.syntax || "ecmascript";
                                if (!bindings && !!fallbackBindings) {
                                    throw new Error("Fallback bindings does not support filesystem access.");
                                } else if (!bindings) {
                                    throw new Error("Bindings not found.");
                                }
                                return [
                                    4,
                                    bindings.parseFile(path, toBuffer(options))
                                ];
                            case 1:
                                res = _state.sent();
                                return [
                                    2,
                                    JSON.parse(res)
                                ];
                        }
                    });
                });
            }
        },
        {
            key: "parseFileSync",
            value: function parseFileSync(path, options) {
                options = options || {
                    syntax: "ecmascript"
                };
                options.syntax = options.syntax || "ecmascript";
                if (!bindings && !!fallbackBindings) {
                    throw new Error("Fallback bindings does not support filesystem access");
                } else if (!bindings) {
                    throw new Error("Bindings not found.");
                }
                return JSON.parse(bindings.parseFileSync(path, toBuffer(options)));
            }
        },
        {
            /**
     * Note: this method should be invoked on the compiler instance used
     *  for `parse()` / `parseSync()`.
     */ key: "print",
            value: function print(m, options) {
                return __awaiter(this, void 0, void 0, function() {
                    return _ts_generator(this, function(_state) {
                        options = options || {};
                        if (bindings) {
                            return [
                                2,
                                bindings.print(JSON.stringify(m), toBuffer(options))
                            ];
                        } else if (fallbackBindings) {
                            return [
                                2,
                                fallbackBindings.print(m, options)
                            ];
                        }
                        throw new Error("Bindings not found.");
                    });
                });
            }
        },
        {
            /**
     * Note: this method should be invoked on the compiler instance used
     *  for `parse()` / `parseSync()`.
     */ key: "printSync",
            value: function printSync(m, options) {
                options = options || {};
                if (bindings) {
                    return bindings.printSync(JSON.stringify(m), toBuffer(options));
                } else if (fallbackBindings) {
                    return fallbackBindings.printSync(m, options);
                }
                throw new Error("Bindings not found.");
            }
        },
        {
            key: "transform",
            value: function transform(src, options) {
                var _a, _b, _c;
                return __awaiter(this, void 0, void 0, function() {
                    var isModule, plugin, newOptions, m, _tmp;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                isModule = typeof src !== "string";
                                options = options || {};
                                if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
                                    options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : "ecmascript";
                                }
                                plugin = options.plugin, newOptions = __rest(options, [
                                    "plugin"
                                ]);
                                if (!bindings) return [
                                    3,
                                    5
                                ];
                                if (!plugin) return [
                                    3,
                                    4
                                ];
                                if (!(typeof src === "string")) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    this.parse(src, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser, options.filename)
                                ];
                            case 1:
                                _tmp = _state.sent();
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                _tmp = src;
                                _state.label = 3;
                            case 3:
                                m = _tmp;
                                return [
                                    2,
                                    this.transform(plugin(m), newOptions)
                                ];
                            case 4:
                                return [
                                    2,
                                    bindings.transform(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions))
                                ];
                            case 5:
                                if (fallbackBindings) {
                                    if (plugin && !this.fallbackBindingsPluginWarningDisplayed) {
                                        console.warn("Fallback bindings does not support legacy plugins, it'll be ignored.");
                                        this.fallbackBindingsPluginWarningDisplayed = true;
                                    }
                                    return [
                                        2,
                                        fallbackBindings.transform(src, options)
                                    ];
                                }
                                _state.label = 6;
                            case 6:
                                throw new Error("Bindings not found.");
                        }
                    });
                });
            }
        },
        {
            key: "transformSync",
            value: function transformSync(src, options) {
                var _a, _b, _c;
                var isModule = typeof src !== "string";
                options = options || {};
                if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
                    options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : "ecmascript";
                }
                var plugin = options.plugin, newOptions = __rest(options, [
                    "plugin"
                ]);
                if (bindings) {
                    if (plugin) {
                        var m = typeof src === "string" ? this.parseSync(src, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser, options.filename) : src;
                        return this.transformSync(plugin(m), newOptions);
                    }
                    return bindings.transformSync(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));
                } else if (fallbackBindings) {
                    if (plugin && !this.fallbackBindingsPluginWarningDisplayed) {
                        console.warn("Fallback bindings does not support legacy plugins, it'll be ignored.");
                        this.fallbackBindingsPluginWarningDisplayed = true;
                    }
                    return fallbackBindings.transformSync(isModule ? JSON.stringify(src) : src, options);
                }
                throw new Error("Bindings not found");
            }
        },
        {
            key: "transformFile",
            value: function transformFile(path, options) {
                var _a, _b, _c;
                return __awaiter(this, void 0, void 0, function() {
                    var plugin, newOptions, m;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!bindings && !!fallbackBindings) {
                                    throw new Error("Fallback bindings does not support filesystem access.");
                                } else if (!bindings) {
                                    throw new Error("Bindings not found.");
                                }
                                options = options || {};
                                if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
                                    options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : "ecmascript";
                                }
                                plugin = options.plugin, newOptions = __rest(options, [
                                    "plugin"
                                ]);
                                newOptions.filename = path;
                                if (!plugin) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    this.parseFile(path, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser)
                                ];
                            case 1:
                                m = _state.sent();
                                return [
                                    2,
                                    this.transform(plugin(m), newOptions)
                                ];
                            case 2:
                                return [
                                    2,
                                    bindings.transformFile(path, false, toBuffer(newOptions))
                                ];
                        }
                    });
                });
            }
        },
        {
            key: "transformFileSync",
            value: function transformFileSync(path, options) {
                var _a, _b, _c;
                if (!bindings && !!fallbackBindings) {
                    throw new Error("Fallback bindings does not support filesystem access.");
                } else if (!bindings) {
                    throw new Error("Bindings not found.");
                }
                options = options || {};
                if ((_a = options === null || options === void 0 ? void 0 : options.jsc) === null || _a === void 0 ? void 0 : _a.parser) {
                    options.jsc.parser.syntax = (_b = options.jsc.parser.syntax) !== null && _b !== void 0 ? _b : "ecmascript";
                }
                var plugin = options.plugin, newOptions = __rest(options, [
                    "plugin"
                ]);
                newOptions.filename = path;
                if (plugin) {
                    var m = this.parseFileSync(path, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser);
                    return this.transformSync(plugin(m), newOptions);
                }
                return bindings.transformFileSync(path, /* isModule */ false, toBuffer(newOptions));
            }
        },
        {
            key: "bundle",
            value: function bundle(options) {
                return __awaiter(this, void 0, void 0, function() {
                    var _this, opts, all, obj, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, o;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                if (!bindings && !!fallbackBindings) {
                                    throw new Error("Fallback bindings does not support this interface yet.");
                                } else if (!bindings) {
                                    throw new Error("Bindings not found.");
                                }
                                return [
                                    4,
                                    (0, spack_1.compileBundleOptions)(options)
                                ];
                            case 1:
                                opts = _state.sent();
                                if (!Array.isArray(opts)) return [
                                    3,
                                    3
                                ];
                                return [
                                    4,
                                    Promise.all(opts.map(function(opt) {
                                        return __awaiter(_this, void 0, void 0, function() {
                                            return _ts_generator(this, function(_state) {
                                                return [
                                                    2,
                                                    this.bundle(opt)
                                                ];
                                            });
                                        });
                                    }))
                                ];
                            case 2:
                                all = _state.sent();
                                obj = {};
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(_iterator = all[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        o = _step.value;
                                        obj = Object.assign(Object.assign({}, obj), o);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return [
                                    2,
                                    obj
                                ];
                            case 3:
                                return [
                                    2,
                                    bindings.bundle(toBuffer(Object.assign({}, opts)))
                                ];
                        }
                    });
                });
            }
        }
    ]);
    return Compiler;
}();
exports.Compiler = Compiler;
var compiler = new Compiler();
function parse(src, options) {
    return compiler.parse(src, options);
}
exports.parse = parse;
function parseSync(src, options) {
    return compiler.parseSync(src, options);
}
exports.parseSync = parseSync;
function parseFile(path, options) {
    return compiler.parseFile(path, options);
}
exports.parseFile = parseFile;
function parseFileSync(path, options) {
    return compiler.parseFileSync(path, options);
}
exports.parseFileSync = parseFileSync;
function print(m, options) {
    return compiler.print(m, options);
}
exports.print = print;
function printSync(m, options) {
    return compiler.printSync(m, options);
}
exports.printSync = printSync;
function transform(src, options) {
    return compiler.transform(src, options);
}
exports.transform = transform;
function transformSync(src, options) {
    return compiler.transformSync(src, options);
}
exports.transformSync = transformSync;
function transformFile(path, options) {
    return compiler.transformFile(path, options);
}
exports.transformFile = transformFile;
function transformFileSync(path, options) {
    return compiler.transformFileSync(path, options);
}
exports.transformFileSync = transformFileSync;
function bundle(options) {
    return compiler.bundle(options);
}
exports.bundle = bundle;
function minify(src, opts) {
    return __awaiter(this, void 0, void 0, function() {
        return _ts_generator(this, function(_state) {
            return [
                2,
                compiler.minify(src, opts)
            ];
        });
    });
}
exports.minify = minify;
function minifySync(src, opts) {
    return compiler.minifySync(src, opts);
}
exports.minifySync = minifySync;
/**
 * Configure custom trace configuration runs for a process lifecycle.
 * Currently only chromium's trace event format is supported.
 * (https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview)
 *
 * This should be called before calling any binding interfaces exported in `@swc/core`, such as
 * `transform*`, or `parse*` or anything. To avoid breaking changes, each binding fn internally
 * sets default trace subscriber if not set.
 *
 * Unlike other configuration, this does not belong to individual api surface using swcrc
 * or api's parameters (`transform(..., {trace})`). This is due to current tracing subscriber
 * can be configured only once for the global scope. Calling `registerGlobalTraceConfig` multiple
 * time won't cause error, subsequent calls will be ignored.
 *
 * As name implies currently this is experimental interface may change over time without semver
 * major breaking changes. Please provide feedbacks,
 * or bug report at https://github.com/swc-project/swc/discussions.
 */ function __experimental_registerGlobalTraceConfig(traceConfig) {
    // Do not raise error if binding doesn't exists - fallback binding will not support
    // this ever.
    if (bindings) {
        if (traceConfig.type === "traceEvent") {
            bindings.initCustomTraceSubscriber(traceConfig.fileName);
        }
    }
}
exports.__experimental_registerGlobalTraceConfig = __experimental_registerGlobalTraceConfig;
/**
 * @ignore
 *
 * Returns current binary's metadata to determine which binary is actually loaded.
 *
 * This is undocumented interface, does not guarantee stability across `@swc/core`'s semver
 * as internal representation may change anytime. Use it with caution.
 */ function getBinaryMetadata() {
    return {
        target: bindings ? bindings === null || bindings === void 0 ? void 0 : bindings.getTargetTriple() : undefined
    };
}
exports.getBinaryMetadata = getBinaryMetadata;
exports.DEFAULT_EXTENSIONS = Object.freeze([
    ".js",
    ".jsx",
    ".es6",
    ".es",
    ".mjs",
    ".ts",
    ".tsx",
    ".cts",
    ".mts"
]);
function toBuffer(t) {
    return Buffer.from(JSON.stringify(t));
}
