"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var _is;
/// <reference lib="es2018"/>
/// <reference lib="dom"/>
/// <reference types="node"/>
Object.defineProperty(exports, "__esModule", {
    value: true
});
var typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array'
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
var objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Blob',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'FormData',
    'URLSearchParams',
    'HTMLElement'
].concat(_to_consumable_array(typedArrayTypeNames));
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
var primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol'
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isOfType(type) {
    return function(value) {
        return (typeof value === "undefined" ? "undefined" : _type_of(value)) === type;
    };
}
var toString = Object.prototype.toString;
var getObjectType = function(value) {
    var objectTypeName = toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
var isObjectOfType = function(type) {
    return function(value) {
        return getObjectType(value) === type;
    };
};
function is(value) {
    if (value === null) {
        return 'null';
    }
    switch(typeof value === "undefined" ? "undefined" : _type_of(value)){
        case 'undefined':
            return 'undefined';
        case 'string':
            return 'string';
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'function':
            return 'Function';
        case 'bigint':
            return 'bigint';
        case 'symbol':
            return 'symbol';
        default:
    }
    if (is.observable(value)) {
        return 'Observable';
    }
    if (is.array(value)) {
        return 'Array';
    }
    if (is.buffer(value)) {
        return 'Buffer';
    }
    var tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (_instanceof(value, String) || _instanceof(value, Boolean) || _instanceof(value, Number)) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
var isNumberType = isOfType('number');
is.number = function(value) {
    return isNumberType(value) && !is.nan(value);
};
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
is.null_ = function(value) {
    return value === null;
};
is.class_ = function(value) {
    return is.function_(value) && value.toString().startsWith('class ');
};
is.boolean = function(value) {
    return value === true || value === false;
};
is.symbol = isOfType('symbol');
is.numericString = function(value) {
    return is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
};
is.array = function(value, assertion) {
    if (!Array.isArray(value)) {
        return false;
    }
    if (!is.function_(assertion)) {
        return true;
    }
    return value.every(assertion);
};
is.buffer = function(value) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
};
is.blob = function(value) {
    return isObjectOfType('Blob')(value);
};
is.nullOrUndefined = function(value) {
    return is.null_(value) || is.undefined(value);
};
is.object = function(value) {
    return !is.null_(value) && ((typeof value === "undefined" ? "undefined" : _type_of(value)) === 'object' || is.function_(value));
};
is.iterable = function(value) {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
};
is.asyncIterable = function(value) {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
};
is.generator = function(value) {
    var _a, _b;
    return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw);
};
is.asyncGenerator = function(value) {
    return is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
};
is.nativePromise = function(value) {
    return isObjectOfType('Promise')(value);
};
var hasPromiseAPI = function(value) {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
};
is.promise = function(value) {
    return is.nativePromise(value) || hasPromiseAPI(value);
};
is.generatorFunction = isObjectOfType('GeneratorFunction');
is.asyncGeneratorFunction = function(value) {
    return getObjectType(value) === 'AsyncGeneratorFunction';
};
is.asyncFunction = function(value) {
    return getObjectType(value) === 'AsyncFunction';
};
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = function(value) {
    return is.function_(value) && !value.hasOwnProperty('prototype');
};
is.regExp = isObjectOfType('RegExp');
is.date = isObjectOfType('Date');
is.error = isObjectOfType('Error');
is.map = function(value) {
    return isObjectOfType('Map')(value);
};
is.set = function(value) {
    return isObjectOfType('Set')(value);
};
is.weakMap = function(value) {
    return isObjectOfType('WeakMap')(value);
};
is.weakSet = function(value) {
    return isObjectOfType('WeakSet')(value);
};
is.int8Array = isObjectOfType('Int8Array');
is.uint8Array = isObjectOfType('Uint8Array');
is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
is.int16Array = isObjectOfType('Int16Array');
is.uint16Array = isObjectOfType('Uint16Array');
is.int32Array = isObjectOfType('Int32Array');
is.uint32Array = isObjectOfType('Uint32Array');
is.float32Array = isObjectOfType('Float32Array');
is.float64Array = isObjectOfType('Float64Array');
is.bigInt64Array = isObjectOfType('BigInt64Array');
is.bigUint64Array = isObjectOfType('BigUint64Array');
is.arrayBuffer = isObjectOfType('ArrayBuffer');
is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
is.dataView = isObjectOfType('DataView');
is.enumCase = function(value, targetEnum) {
    return Object.values(targetEnum).includes(value);
};
is.directInstanceOf = function(instance, class_) {
    return Object.getPrototypeOf(instance) === class_.prototype;
};
is.urlInstance = function(value) {
    return isObjectOfType('URL')(value);
};
is.urlString = function(value) {
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    } catch (_a) {
        return false;
    }
};
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = function(value) {
    return Boolean(value);
};
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = function(value) {
    return !value;
};
is.nan = function(value) {
    return Number.isNaN(value);
};
is.primitive = function(value) {
    return is.null_(value) || isPrimitiveTypeName(typeof value === "undefined" ? "undefined" : _type_of(value));
};
is.integer = function(value) {
    return Number.isInteger(value);
};
is.safeInteger = function(value) {
    return Number.isSafeInteger(value);
};
is.plainObject = function(value) {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (toString.call(value) !== '[object Object]') {
        return false;
    }
    var prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
};
is.typedArray = function(value) {
    return isTypedArrayName(getObjectType(value));
};
var isValidLength = function(value) {
    return is.safeInteger(value) && value >= 0;
};
is.arrayLike = function(value) {
    return !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
};
is.inRange = function(value, range) {
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        var _Math, _Math1;
        return value >= (_Math = Math).min.apply(_Math, _to_consumable_array(range)) && value <= (_Math1 = Math).max.apply(_Math1, _to_consumable_array(range));
    }
    throw new TypeError("Invalid range: ".concat(JSON.stringify(range)));
};
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue'
];
is.domElement = function(value) {
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(function(property) {
        return property in value;
    });
};
is.observable = function(value) {
    var _a, _b, _c, _d;
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
    }
    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
    }
    return false;
};
is.nodeStream = function(value) {
    return is.object(value) && is.function_(value.pipe) && !is.observable(value);
};
is.infinite = function(value) {
    return value === Infinity || value === -Infinity;
};
var isAbsoluteMod2 = function(remainder) {
    return function(value) {
        return is.integer(value) && Math.abs(value % 2) === remainder;
    };
};
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = function(value) {
    return is.array(value) && value.length === 0;
};
is.nonEmptyArray = function(value) {
    return is.array(value) && value.length > 0;
};
is.emptyString = function(value) {
    return is.string(value) && value.length === 0;
};
var isWhiteSpaceString = function(value) {
    return is.string(value) && !/\S/.test(value);
};
is.emptyStringOrWhitespace = function(value) {
    return is.emptyString(value) || isWhiteSpaceString(value);
};
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = function(value) {
    return is.string(value) && value.length > 0;
};
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyStringAndNotWhitespace = function(value) {
    return is.string(value) && !is.emptyStringOrWhitespace(value);
};
is.emptyObject = function(value) {
    return is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
};
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
is.nonEmptyObject = function(value) {
    return is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
};
is.emptySet = function(value) {
    return is.set(value) && value.size === 0;
};
is.nonEmptySet = function(value) {
    return is.set(value) && value.size > 0;
};
is.emptyMap = function(value) {
    return is.map(value) && value.size === 0;
};
is.nonEmptyMap = function(value) {
    return is.map(value) && value.size > 0;
};
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
is.propertyKey = function(value) {
    return is.any([
        is.string,
        is.number,
        is.symbol
    ], value);
};
is.formData = function(value) {
    return isObjectOfType('FormData')(value);
};
is.urlSearchParams = function(value) {
    return isObjectOfType('URLSearchParams')(value);
};
var predicateOnArray = function(method, predicate, values) {
    if (!is.function_(predicate)) {
        throw new TypeError("Invalid predicate: ".concat(JSON.stringify(predicate)));
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = function(predicate) {
    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        values[_key - 1] = arguments[_key];
    }
    var predicates = is.array(predicate) ? predicate : [
        predicate
    ];
    return predicates.some(function(singlePredicate) {
        return predicateOnArray(Array.prototype.some, singlePredicate, values);
    });
};
is.all = function(predicate) {
    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        values[_key - 1] = arguments[_key];
    }
    return predicateOnArray(Array.prototype.every, predicate, values);
};
var assertType = function(condition, description, value) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!condition) {
        var multipleValues = options.multipleValues;
        var valuesMessage = multipleValues ? "received values of types ".concat(_to_consumable_array(new Set(value.map(function(singleValue) {
            return "`".concat(is(singleValue), "`");
        }))).join(', ')) : "received value of type `".concat(is(value), "`");
        throw new TypeError("Expected value which is `".concat(description, "`, ").concat(valuesMessage, "."));
    }
};
exports.assert = {
    // Unknowns.
    undefined: function(value) {
        return assertType(is.undefined(value), 'undefined', value);
    },
    string: function(value) {
        return assertType(is.string(value), 'string', value);
    },
    number: function(value) {
        return assertType(is.number(value), 'number', value);
    },
    bigint: function(value) {
        return assertType(is.bigint(value), 'bigint', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: function(value) {
        return assertType(is.function_(value), 'Function', value);
    },
    null_: function(value) {
        return assertType(is.null_(value), 'null', value);
    },
    class_: function(value) {
        return assertType(is.class_(value), "Class" /* class_ */ , value);
    },
    boolean: function(value) {
        return assertType(is.boolean(value), 'boolean', value);
    },
    symbol: function(value) {
        return assertType(is.symbol(value), 'symbol', value);
    },
    numericString: function(value) {
        return assertType(is.numericString(value), "string with a number" /* numericString */ , value);
    },
    array: function(value, assertion) {
        var assert = assertType;
        assert(is.array(value), 'Array', value);
        if (assertion) {
            value.forEach(assertion);
        }
    },
    buffer: function(value) {
        return assertType(is.buffer(value), 'Buffer', value);
    },
    blob: function(value) {
        return assertType(is.blob(value), 'Blob', value);
    },
    nullOrUndefined: function(value) {
        return assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */ , value);
    },
    object: function(value) {
        return assertType(is.object(value), 'Object', value);
    },
    iterable: function(value) {
        return assertType(is.iterable(value), "Iterable" /* iterable */ , value);
    },
    asyncIterable: function(value) {
        return assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */ , value);
    },
    generator: function(value) {
        return assertType(is.generator(value), 'Generator', value);
    },
    asyncGenerator: function(value) {
        return assertType(is.asyncGenerator(value), 'AsyncGenerator', value);
    },
    nativePromise: function(value) {
        return assertType(is.nativePromise(value), "native Promise" /* nativePromise */ , value);
    },
    promise: function(value) {
        return assertType(is.promise(value), 'Promise', value);
    },
    generatorFunction: function(value) {
        return assertType(is.generatorFunction(value), 'GeneratorFunction', value);
    },
    asyncGeneratorFunction: function(value) {
        return assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: function(value) {
        return assertType(is.asyncFunction(value), 'AsyncFunction', value);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: function(value) {
        return assertType(is.boundFunction(value), 'Function', value);
    },
    regExp: function(value) {
        return assertType(is.regExp(value), 'RegExp', value);
    },
    date: function(value) {
        return assertType(is.date(value), 'Date', value);
    },
    error: function(value) {
        return assertType(is.error(value), 'Error', value);
    },
    map: function(value) {
        return assertType(is.map(value), 'Map', value);
    },
    set: function(value) {
        return assertType(is.set(value), 'Set', value);
    },
    weakMap: function(value) {
        return assertType(is.weakMap(value), 'WeakMap', value);
    },
    weakSet: function(value) {
        return assertType(is.weakSet(value), 'WeakSet', value);
    },
    int8Array: function(value) {
        return assertType(is.int8Array(value), 'Int8Array', value);
    },
    uint8Array: function(value) {
        return assertType(is.uint8Array(value), 'Uint8Array', value);
    },
    uint8ClampedArray: function(value) {
        return assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value);
    },
    int16Array: function(value) {
        return assertType(is.int16Array(value), 'Int16Array', value);
    },
    uint16Array: function(value) {
        return assertType(is.uint16Array(value), 'Uint16Array', value);
    },
    int32Array: function(value) {
        return assertType(is.int32Array(value), 'Int32Array', value);
    },
    uint32Array: function(value) {
        return assertType(is.uint32Array(value), 'Uint32Array', value);
    },
    float32Array: function(value) {
        return assertType(is.float32Array(value), 'Float32Array', value);
    },
    float64Array: function(value) {
        return assertType(is.float64Array(value), 'Float64Array', value);
    },
    bigInt64Array: function(value) {
        return assertType(is.bigInt64Array(value), 'BigInt64Array', value);
    },
    bigUint64Array: function(value) {
        return assertType(is.bigUint64Array(value), 'BigUint64Array', value);
    },
    arrayBuffer: function(value) {
        return assertType(is.arrayBuffer(value), 'ArrayBuffer', value);
    },
    sharedArrayBuffer: function(value) {
        return assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value);
    },
    dataView: function(value) {
        return assertType(is.dataView(value), 'DataView', value);
    },
    enumCase: function(value, targetEnum) {
        return assertType(is.enumCase(value, targetEnum), 'EnumCase', value);
    },
    urlInstance: function(value) {
        return assertType(is.urlInstance(value), 'URL', value);
    },
    urlString: function(value) {
        return assertType(is.urlString(value), "string with a URL" /* urlString */ , value);
    },
    truthy: function(value) {
        return assertType(is.truthy(value), "truthy" /* truthy */ , value);
    },
    falsy: function(value) {
        return assertType(is.falsy(value), "falsy" /* falsy */ , value);
    },
    nan: function(value) {
        return assertType(is.nan(value), "NaN" /* nan */ , value);
    },
    primitive: function(value) {
        return assertType(is.primitive(value), "primitive" /* primitive */ , value);
    },
    integer: function(value) {
        return assertType(is.integer(value), "integer" /* integer */ , value);
    },
    safeInteger: function(value) {
        return assertType(is.safeInteger(value), "integer" /* safeInteger */ , value);
    },
    plainObject: function(value) {
        return assertType(is.plainObject(value), "plain object" /* plainObject */ , value);
    },
    typedArray: function(value) {
        return assertType(is.typedArray(value), "TypedArray" /* typedArray */ , value);
    },
    arrayLike: function(value) {
        return assertType(is.arrayLike(value), "array-like" /* arrayLike */ , value);
    },
    domElement: function(value) {
        return assertType(is.domElement(value), "HTMLElement" /* domElement */ , value);
    },
    observable: function(value) {
        return assertType(is.observable(value), 'Observable', value);
    },
    nodeStream: function(value) {
        return assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */ , value);
    },
    infinite: function(value) {
        return assertType(is.infinite(value), "infinite number" /* infinite */ , value);
    },
    emptyArray: function(value) {
        return assertType(is.emptyArray(value), "empty array" /* emptyArray */ , value);
    },
    nonEmptyArray: function(value) {
        return assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */ , value);
    },
    emptyString: function(value) {
        return assertType(is.emptyString(value), "empty string" /* emptyString */ , value);
    },
    emptyStringOrWhitespace: function(value) {
        return assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */ , value);
    },
    nonEmptyString: function(value) {
        return assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */ , value);
    },
    nonEmptyStringAndNotWhitespace: function(value) {
        return assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* nonEmptyStringAndNotWhitespace */ , value);
    },
    emptyObject: function(value) {
        return assertType(is.emptyObject(value), "empty object" /* emptyObject */ , value);
    },
    nonEmptyObject: function(value) {
        return assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */ , value);
    },
    emptySet: function(value) {
        return assertType(is.emptySet(value), "empty set" /* emptySet */ , value);
    },
    nonEmptySet: function(value) {
        return assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */ , value);
    },
    emptyMap: function(value) {
        return assertType(is.emptyMap(value), "empty map" /* emptyMap */ , value);
    },
    nonEmptyMap: function(value) {
        return assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */ , value);
    },
    propertyKey: function(value) {
        return assertType(is.propertyKey(value), 'PropertyKey', value);
    },
    formData: function(value) {
        return assertType(is.formData(value), 'FormData', value);
    },
    urlSearchParams: function(value) {
        return assertType(is.urlSearchParams(value), 'URLSearchParams', value);
    },
    // Numbers.
    evenInteger: function(value) {
        return assertType(is.evenInteger(value), "even integer" /* evenInteger */ , value);
    },
    oddInteger: function(value) {
        return assertType(is.oddInteger(value), "odd integer" /* oddInteger */ , value);
    },
    // Two arguments.
    directInstanceOf: function(instance, class_) {
        return assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */ , instance);
    },
    inRange: function(value, range) {
        return assertType(is.inRange(value, range), "in range" /* inRange */ , value);
    },
    // Variadic functions.
    any: function(predicate) {
        for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            values[_key - 1] = arguments[_key];
        }
        var _is;
        return assertType((_is = is).any.apply(_is, [
            predicate
        ].concat(_to_consumable_array(values))), "predicate returns truthy for any value" /* any */ , values, {
            multipleValues: true
        });
    },
    all: function(predicate) {
        for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            values[_key - 1] = arguments[_key];
        }
        return assertType((_is = is).all.apply(_is, [
            predicate
        ].concat(_to_consumable_array(values))), "predicate returns truthy for all values" /* all */ , values, {
            multipleValues: true
        });
    }
};
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
Object.defineProperties(exports.assert, {
    class: {
        value: exports.assert.class_
    },
    function: {
        value: exports.assert.function_
    },
    null: {
        value: exports.assert.null_
    }
});
exports.default = is;
// For CommonJS default export support
module.exports = is;
module.exports.default = is;
module.exports.assert = exports.assert;
