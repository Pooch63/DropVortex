function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var humanReadableArgName = require('./argument.js').humanReadableArgName;
/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */ // @ts-check
// Although this is a class, methods are static in style to allow override using subclass or just functions.
var Help = /*#__PURE__*/ function() {
    "use strict";
    function Help() {
        _class_call_check(this, Help);
        this.helpWidth = undefined;
        this.sortSubcommands = false;
        this.sortOptions = false;
    }
    _create_class(Help, [
        {
            /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */ key: "visibleCommands",
            value: function visibleCommands(cmd) {
                var visibleCommands = cmd.commands.filter(function(cmd) {
                    return !cmd._hidden;
                });
                if (cmd._hasImplicitHelpCommand()) {
                    // Create a command matching the implicit help command.
                    var _cmd__helpCommandnameAndArgs_match = _sliced_to_array(cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/), 3), helpName = _cmd__helpCommandnameAndArgs_match[1], helpArgs = _cmd__helpCommandnameAndArgs_match[2];
                    var helpCommand = cmd.createCommand(helpName).helpOption(false);
                    helpCommand.description(cmd._helpCommandDescription);
                    if (helpArgs) helpCommand.arguments(helpArgs);
                    visibleCommands.push(helpCommand);
                }
                if (this.sortSubcommands) {
                    visibleCommands.sort(function(a, b) {
                        // @ts-ignore: overloaded return type
                        return a.name().localeCompare(b.name());
                    });
                }
                return visibleCommands;
            }
        },
        {
            /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */ key: "visibleOptions",
            value: function visibleOptions(cmd) {
                var visibleOptions = cmd.options.filter(function(option) {
                    return !option.hidden;
                });
                // Implicit help
                var showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
                var showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
                if (showShortHelpFlag || showLongHelpFlag) {
                    var helpOption;
                    if (!showShortHelpFlag) {
                        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
                    } else if (!showLongHelpFlag) {
                        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
                    } else {
                        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
                    }
                    visibleOptions.push(helpOption);
                }
                if (this.sortOptions) {
                    var getSortKey = function(option) {
                        // WYSIWYG for order displayed in help with short before long, no special handling for negated.
                        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
                    };
                    visibleOptions.sort(function(a, b) {
                        return getSortKey(a).localeCompare(getSortKey(b));
                    });
                }
                return visibleOptions;
            }
        },
        {
            /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */ key: "visibleArguments",
            value: function visibleArguments(cmd) {
                // Side effect! Apply the legacy descriptions before the arguments are displayed.
                if (cmd._argsDescription) {
                    cmd._args.forEach(function(argument) {
                        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
                    });
                }
                // If there are any arguments with a description then return all the arguments.
                if (cmd._args.find(function(argument) {
                    return argument.description;
                })) {
                    return cmd._args;
                }
                ;
                return [];
            }
        },
        {
            /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */ key: "subcommandTerm",
            value: function subcommandTerm(cmd) {
                // Legacy. Ignores custom usage string, and nested commands.
                var args = cmd._args.map(function(arg) {
                    return humanReadableArgName(arg);
                }).join(' ');
                return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
                (args ? ' ' + args : '');
            }
        },
        {
            /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */ key: "optionTerm",
            value: function optionTerm(option) {
                return option.flags;
            }
        },
        {
            /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */ key: "argumentTerm",
            value: function argumentTerm(argument) {
                return argument.name();
            }
        },
        {
            /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */ key: "longestSubcommandTermLength",
            value: function longestSubcommandTermLength(cmd, helper) {
                return helper.visibleCommands(cmd).reduce(function(max, command) {
                    return Math.max(max, helper.subcommandTerm(command).length);
                }, 0);
            }
        },
        {
            /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */ key: "longestOptionTermLength",
            value: function longestOptionTermLength(cmd, helper) {
                return helper.visibleOptions(cmd).reduce(function(max, option) {
                    return Math.max(max, helper.optionTerm(option).length);
                }, 0);
            }
        },
        {
            /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */ key: "longestArgumentTermLength",
            value: function longestArgumentTermLength(cmd, helper) {
                return helper.visibleArguments(cmd).reduce(function(max, argument) {
                    return Math.max(max, helper.argumentTerm(argument).length);
                }, 0);
            }
        },
        {
            /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */ key: "commandUsage",
            value: function commandUsage(cmd) {
                // Usage
                var cmdName = cmd._name;
                if (cmd._aliases[0]) {
                    cmdName = cmdName + '|' + cmd._aliases[0];
                }
                var parentCmdNames = '';
                for(var parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent){
                    parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
                }
                return parentCmdNames + cmdName + ' ' + cmd.usage();
            }
        },
        {
            /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */ key: "commandDescription",
            value: function commandDescription(cmd) {
                // @ts-ignore: overloaded return type
                return cmd.description();
            }
        },
        {
            /**
   * Get the command description to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */ key: "subcommandDescription",
            value: function subcommandDescription(cmd) {
                // @ts-ignore: overloaded return type
                return cmd.description();
            }
        },
        {
            /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */ key: "optionDescription",
            value: function optionDescription(option) {
                var extraInfo = [];
                // Some of these do not make sense for negated boolean and suppress for backwards compatibility.
                if (option.argChoices && !option.negate) {
                    extraInfo.push(// use stringify to match the display of the default value
                    "choices: ".concat(option.argChoices.map(function(choice) {
                        return JSON.stringify(choice);
                    }).join(', ')));
                }
                if (option.defaultValue !== undefined && !option.negate) {
                    extraInfo.push("default: ".concat(option.defaultValueDescription || JSON.stringify(option.defaultValue)));
                }
                if (option.envVar !== undefined) {
                    extraInfo.push("env: ".concat(option.envVar));
                }
                if (extraInfo.length > 0) {
                    return "".concat(option.description, " (").concat(extraInfo.join(', '), ")");
                }
                return option.description;
            }
        },
        {
            /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */ key: "argumentDescription",
            value: function argumentDescription(argument) {
                var extraInfo = [];
                if (argument.argChoices) {
                    extraInfo.push(// use stringify to match the display of the default value
                    "choices: ".concat(argument.argChoices.map(function(choice) {
                        return JSON.stringify(choice);
                    }).join(', ')));
                }
                if (argument.defaultValue !== undefined) {
                    extraInfo.push("default: ".concat(argument.defaultValueDescription || JSON.stringify(argument.defaultValue)));
                }
                if (extraInfo.length > 0) {
                    var extraDescripton = "(".concat(extraInfo.join(', '), ")");
                    if (argument.description) {
                        return "".concat(argument.description, " ").concat(extraDescripton);
                    }
                    return extraDescripton;
                }
                return argument.description;
            }
        },
        {
            /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */ key: "formatHelp",
            value: function formatHelp(cmd, helper) {
                var termWidth = helper.padWidth(cmd, helper);
                var helpWidth = helper.helpWidth || 80;
                var itemIndentWidth = 2;
                var itemSeparatorWidth = 2; // between term and description
                function formatItem(term, description) {
                    if (description) {
                        var fullText = "".concat(term.padEnd(termWidth + itemSeparatorWidth)).concat(description);
                        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
                    }
                    return term;
                }
                ;
                function formatList(textArray) {
                    return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
                }
                // Usage
                var output = [
                    "Usage: ".concat(helper.commandUsage(cmd)),
                    ''
                ];
                // Description
                var commandDescription = helper.commandDescription(cmd);
                if (commandDescription.length > 0) {
                    output = output.concat([
                        commandDescription,
                        ''
                    ]);
                }
                // Arguments
                var argumentList = helper.visibleArguments(cmd).map(function(argument) {
                    return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
                });
                if (argumentList.length > 0) {
                    output = output.concat([
                        'Arguments:',
                        formatList(argumentList),
                        ''
                    ]);
                }
                // Options
                var optionList = helper.visibleOptions(cmd).map(function(option) {
                    return formatItem(helper.optionTerm(option), helper.optionDescription(option));
                });
                if (optionList.length > 0) {
                    output = output.concat([
                        'Options:',
                        formatList(optionList),
                        ''
                    ]);
                }
                // Commands
                var commandList = helper.visibleCommands(cmd).map(function(cmd) {
                    return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
                });
                if (commandList.length > 0) {
                    output = output.concat([
                        'Commands:',
                        formatList(commandList),
                        ''
                    ]);
                }
                return output.join('\n');
            }
        },
        {
            /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */ key: "padWidth",
            value: function padWidth(cmd, helper) {
                return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
            }
        },
        {
            /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */ key: "wrap",
            value: function wrap(str, width, indent) {
                var minColumnWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
                // Detect manually wrapped and indented strings by searching for line breaks
                // followed by multiple spaces/tabs.
                if (str.match(/[\n]\s+/)) return str;
                // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
                var columnWidth = width - indent;
                if (columnWidth < minColumnWidth) return str;
                var leadingStr = str.substr(0, indent);
                var columnText = str.substr(indent);
                var indentString = ' '.repeat(indent);
                var regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)', 'g');
                var lines = columnText.match(regex) || [];
                return leadingStr + lines.map(function(line, i) {
                    if (line.slice(-1) === '\n') {
                        line = line.slice(0, line.length - 1);
                    }
                    return (i > 0 ? indentString : '') + line.trimRight();
                }).join('\n');
            }
        }
    ]);
    return Help;
}();
exports.Help = Help;
