var maxDistance = 3;
function editDistance(a, b) {
    // https://en.wikipedia.org/wiki/Damerauâ€“Levenshtein_distance
    // Calculating optimal string alignment distance, no substring is edited more than once.
    // (Simple implementation.)
    // Quick early exit, return worst case.
    if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);
    // distance between prefix substrings of a and b
    var d = [];
    // pure deletions turn a into empty string
    for(var i = 0; i <= a.length; i++){
        d[i] = [
            i
        ];
    }
    // pure insertions turn empty string into b
    for(var j = 0; j <= b.length; j++){
        d[0][j] = j;
    }
    // fill matrix
    for(var j1 = 1; j1 <= b.length; j1++){
        for(var i1 = 1; i1 <= a.length; i1++){
            var cost = 1;
            if (a[i1 - 1] === b[j1 - 1]) {
                cost = 0;
            } else {
                cost = 1;
            }
            d[i1][j1] = Math.min(d[i1 - 1][j1] + 1, d[i1][j1 - 1] + 1, d[i1 - 1][j1 - 1] + cost // substitution
            );
            // transposition
            if (i1 > 1 && j1 > 1 && a[i1 - 1] === b[j1 - 2] && a[i1 - 2] === b[j1 - 1]) {
                d[i1][j1] = Math.min(d[i1][j1], d[i1 - 2][j1 - 2] + 1);
            }
        }
    }
    return d[a.length][b.length];
}
/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */ function suggestSimilar(word, candidates) {
    if (!candidates || candidates.length === 0) return '';
    // remove possible duplicates
    candidates = Array.from(new Set(candidates));
    var searchingOptions = word.startsWith('--');
    if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map(function(candidate) {
            return candidate.slice(2);
        });
    }
    var similar = [];
    var bestDistance = maxDistance;
    var minSimilarity = 0.4;
    candidates.forEach(function(candidate) {
        if (candidate.length <= 1) return; // no one character guesses
        var distance = editDistance(word, candidate);
        var length = Math.max(word.length, candidate.length);
        var similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
            if (distance < bestDistance) {
                // better edit distance, throw away previous worse matches
                bestDistance = distance;
                similar = [
                    candidate
                ];
            } else if (distance === bestDistance) {
                similar.push(candidate);
            }
        }
    });
    similar.sort(function(a, b) {
        return a.localeCompare(b);
    });
    if (searchingOptions) {
        similar = similar.map(function(candidate) {
            return "--".concat(candidate);
        });
    }
    if (similar.length > 1) {
        return "\n(Did you mean one of ".concat(similar.join(', '), "?)");
    }
    if (similar.length === 1) {
        return "\n(Did you mean ".concat(similar[0], "?)");
    }
    return '';
}
exports.suggestSimilar = suggestSimilar;
