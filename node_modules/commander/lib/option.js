function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var InvalidArgumentError = require('./error.js').InvalidArgumentError;
// @ts-check
var Option = /*#__PURE__*/ function() {
    "use strict";
    function Option(flags, description) {
        _class_call_check(this, Option);
        this.flags = flags;
        this.description = description || '';
        this.required = flags.includes('<'); // A value must be supplied when the option is specified.
        this.optional = flags.includes('['); // A value is optional when the option is specified.
        // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
        this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
        this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
        var optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
            this.negate = this.long.startsWith('--no-');
        }
        this.defaultValue = undefined;
        this.defaultValueDescription = undefined;
        this.envVar = undefined;
        this.parseArg = undefined;
        this.hidden = false;
        this.argChoices = undefined;
    }
    _create_class(Option, [
        {
            /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any} value
   * @param {string} [description]
   * @return {Option}
   */ key: "default",
            value: function _default(value, description) {
                this.defaultValue = value;
                this.defaultValueDescription = description;
                return this;
            }
        },
        {
            /**
   * Set environment variable to check for option value.
   * Priority order of option values is default < env < cli
   *
   * @param {string} name
   * @return {Option}
   */ key: "env",
            value: function env(name) {
                this.envVar = name;
                return this;
            }
        },
        {
            /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */ key: "argParser",
            value: function argParser(fn) {
                this.parseArg = fn;
                return this;
            }
        },
        {
            /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */ key: "makeOptionMandatory",
            value: function makeOptionMandatory() {
                var mandatory = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.mandatory = !!mandatory;
                return this;
            }
        },
        {
            /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */ key: "hideHelp",
            value: function hideHelp() {
                var hide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this.hidden = !!hide;
                return this;
            }
        },
        {
            /**
   * @api private
   */ key: "_concatValue",
            value: function _concatValue(value, previous) {
                if (previous === this.defaultValue || !Array.isArray(previous)) {
                    return [
                        value
                    ];
                }
                return previous.concat(value);
            }
        },
        {
            /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */ key: "choices",
            value: function choices(values) {
                var _this = this;
                this.argChoices = values;
                this.parseArg = function(arg, previous) {
                    if (!values.includes(arg)) {
                        throw new InvalidArgumentError("Allowed choices are ".concat(values.join(', '), "."));
                    }
                    if (_this.variadic) {
                        return _this._concatValue(arg, previous);
                    }
                    return arg;
                };
                return this;
            }
        },
        {
            /**
   * Return option name.
   *
   * @return {string}
   */ key: "name",
            value: function name() {
                if (this.long) {
                    return this.long.replace(/^--/, '');
                }
                return this.short.replace(/^-/, '');
            }
        },
        {
            /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   * @api private
   */ key: "attributeName",
            value: function attributeName() {
                return camelcase(this.name().replace(/^no-/, ''));
            }
        },
        {
            /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @api private
   */ key: "is",
            value: function is(arg) {
                return this.short === arg || this.long === arg;
            }
        }
    ]);
    return Option;
}();
/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @api private
 */ function camelcase(str) {
    return str.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
    });
}
/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @api private
 */ function splitOptionFlags(flags) {
    var shortFlag;
    var longFlag;
    // Use original very loose parsing to maintain backwards compatibility for now,
    // which allowed for example unintended `-sw, --short-word` [sic].
    var flagParts = flags.split(/[ |,]+/);
    if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();
    longFlag = flagParts.shift();
    // Add support for lone short flag without significantly changing parsing!
    if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = undefined;
    }
    return {
        shortFlag: shortFlag,
        longFlag: longFlag
    };
}
exports.Option = Option;
exports.splitOptionFlags = splitOptionFlags;
