function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct();
    return function _createSuperInternal() {
        var Super = _get_prototype_of(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return(this, result);
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var EventEmitter = require('events').EventEmitter;
var childProcess = require('child_process');
var path = require('path');
var fs = require('fs');
var _require = require('./argument.js'), Argument = _require.Argument, humanReadableArgName = _require.humanReadableArgName;
var CommanderError = require('./error.js').CommanderError;
var Help = require('./help.js').Help;
var _require1 = require('./option.js'), Option = _require1.Option, splitOptionFlags = _require1.splitOptionFlags;
var suggestSimilar = require('./suggestSimilar').suggestSimilar;
// @ts-check
var Command = /*#__PURE__*/ function(EventEmitter) {
    "use strict";
    _inherits(Command, EventEmitter);
    var _super = _create_super(Command);
    function Command(name) {
        _class_call_check(this, Command);
        var _this;
        _this = _super.call(this);
        /** @type {Command[]} */ _this.commands = [];
        /** @type {Option[]} */ _this.options = [];
        _this.parent = null;
        _this._allowUnknownOption = false;
        _this._allowExcessArguments = true;
        /** @type {Argument[]} */ _this._args = [];
        /** @type {string[]} */ _this.args = []; // cli args with options removed
        _this.rawArgs = [];
        _this.processedArgs = []; // like .args but after custom processing and collecting variadic
        _this._scriptPath = null;
        _this._name = name || '';
        _this._optionValues = {};
        _this._optionValueSources = {}; // default < config < env < cli
        _this._storeOptionsAsProperties = false;
        _this._actionHandler = null;
        _this._executableHandler = false;
        _this._executableFile = null; // custom name for executable
        _this._defaultCommandName = null;
        _this._exitCallback = null;
        _this._aliases = [];
        _this._combineFlagAndOptionalValue = true;
        _this._description = '';
        _this._argsDescription = undefined; // legacy
        _this._enablePositionalOptions = false;
        _this._passThroughOptions = false;
        _this._lifeCycleHooks = {}; // a hash of arrays
        /** @type {boolean | string} */ _this._showHelpAfterError = false;
        _this._showSuggestionAfterError = false;
        // see .configureOutput() for docs
        _this._outputConfiguration = {
            writeOut: function(str) {
                return process.stdout.write(str);
            },
            writeErr: function(str) {
                return process.stderr.write(str);
            },
            getOutHelpWidth: function() {
                return process.stdout.isTTY ? process.stdout.columns : undefined;
            },
            getErrHelpWidth: function() {
                return process.stderr.isTTY ? process.stderr.columns : undefined;
            },
            outputError: function(str, write) {
                return write(str);
            }
        };
        _this._hidden = false;
        _this._hasHelpOption = true;
        _this._helpFlags = '-h, --help';
        _this._helpDescription = 'display help for command';
        _this._helpShortFlag = '-h';
        _this._helpLongFlag = '--help';
        _this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
        _this._helpCommandName = 'help';
        _this._helpCommandnameAndArgs = 'help [command]';
        _this._helpCommandDescription = 'display help for command';
        _this._helpConfiguration = {};
        return _this;
    }
    _create_class(Command, [
        {
            /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} returns `this` for executable command
   */ key: "copyInheritedSettings",
            value: function copyInheritedSettings(sourceCommand) {
                this._outputConfiguration = sourceCommand._outputConfiguration;
                this._hasHelpOption = sourceCommand._hasHelpOption;
                this._helpFlags = sourceCommand._helpFlags;
                this._helpDescription = sourceCommand._helpDescription;
                this._helpShortFlag = sourceCommand._helpShortFlag;
                this._helpLongFlag = sourceCommand._helpLongFlag;
                this._helpCommandName = sourceCommand._helpCommandName;
                this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
                this._helpCommandDescription = sourceCommand._helpCommandDescription;
                this._helpConfiguration = sourceCommand._helpConfiguration;
                this._exitCallback = sourceCommand._exitCallback;
                this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
                this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
                this._allowExcessArguments = sourceCommand._allowExcessArguments;
                this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
                this._showHelpAfterError = sourceCommand._showHelpAfterError;
                this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
                return this;
            }
        },
        {
            /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */ key: "command",
            value: function command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
                var desc = actionOptsOrExecDesc;
                var opts = execOpts;
                if ((typeof desc === "undefined" ? "undefined" : _type_of(desc)) === 'object' && desc !== null) {
                    opts = desc;
                    desc = null;
                }
                opts = opts || {};
                var _nameAndArgs_match = _sliced_to_array(nameAndArgs.match(/([^ ]+) *(.*)/), 3), name = _nameAndArgs_match[1], args = _nameAndArgs_match[2];
                var cmd = this.createCommand(name);
                if (desc) {
                    cmd.description(desc);
                    cmd._executableHandler = true;
                }
                if (opts.isDefault) this._defaultCommandName = cmd._name;
                cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
                cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
                if (args) cmd.arguments(args);
                this.commands.push(cmd);
                cmd.parent = this;
                cmd.copyInheritedSettings(this);
                if (desc) return this;
                return cmd;
            }
        },
        {
            /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */ key: "createCommand",
            value: function createCommand(name) {
                return new Command(name);
            }
        },
        {
            /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */ key: "createHelp",
            value: function createHelp() {
                return Object.assign(new Help(), this.configureHelp());
            }
        },
        {
            /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */ key: "configureHelp",
            value: function configureHelp(configuration) {
                if (configuration === undefined) return this._helpConfiguration;
                this._helpConfiguration = configuration;
                return this;
            }
        },
        {
            /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */ key: "configureOutput",
            value: function configureOutput(configuration) {
                if (configuration === undefined) return this._outputConfiguration;
                Object.assign(this._outputConfiguration, configuration);
                return this;
            }
        },
        {
            /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp]
   * @return {Command} `this` command for chaining
   */ key: "showHelpAfterError",
            value: function showHelpAfterError() {
                var displayHelp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
                this._showHelpAfterError = displayHelp;
                return this;
            }
        },
        {
            /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */ key: "showSuggestionAfterError",
            value: function showSuggestionAfterError() {
                var displaySuggestion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._showSuggestionAfterError = !!displaySuggestion;
                return this;
            }
        },
        {
            /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {Object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */ key: "addCommand",
            value: function addCommand(cmd, opts) {
                if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');
                // To keep things simple, block automatic name generation for deeply nested executables.
                // Fail fast and detect when adding rather than later when parsing.
                function checkExplicitNames(commandArray) {
                    commandArray.forEach(function(cmd) {
                        if (cmd._executableHandler && !cmd._executableFile) {
                            throw new Error("Must specify executableFile for deeply nested executable: ".concat(cmd.name()));
                        }
                        checkExplicitNames(cmd.commands);
                    });
                }
                checkExplicitNames(cmd.commands);
                opts = opts || {};
                if (opts.isDefault) this._defaultCommandName = cmd._name;
                if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation
                this.commands.push(cmd);
                cmd.parent = this;
                return this;
            }
        },
        {
            /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */ key: "createArgument",
            value: function createArgument(name, description) {
                return new Argument(name, description);
            }
        },
        {
            /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {Function|*} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */ key: "argument",
            value: function argument(name, description, fn, defaultValue) {
                var argument = this.createArgument(name, description);
                if (typeof fn === 'function') {
                    argument.default(defaultValue).argParser(fn);
                } else {
                    argument.default(fn);
                }
                this.addArgument(argument);
                return this;
            }
        },
        {
            /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */ key: "arguments",
            value: function _arguments(names) {
                var _this = this;
                names.split(/ +/).forEach(function(detail) {
                    _this.argument(detail);
                });
                return this;
            }
        },
        {
            /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */ key: "addArgument",
            value: function addArgument(argument) {
                var previousArgument = this._args.slice(-1)[0];
                if (previousArgument && previousArgument.variadic) {
                    throw new Error("only the last argument can be variadic '".concat(previousArgument.name(), "'"));
                }
                if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
                    throw new Error("a default value for a required argument is never used: '".concat(argument.name(), "'"));
                }
                this._args.push(argument);
                return this;
            }
        },
        {
            /**
   * Override default decision whether to add implicit help command.
   *
   *    addHelpCommand() // force on
   *    addHelpCommand(false); // force off
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command} `this` command for chaining
   */ key: "addHelpCommand",
            value: function addHelpCommand(enableOrNameAndArgs, description) {
                if (enableOrNameAndArgs === false) {
                    this._addImplicitHelpCommand = false;
                } else {
                    this._addImplicitHelpCommand = true;
                    if (typeof enableOrNameAndArgs === 'string') {
                        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
                        this._helpCommandnameAndArgs = enableOrNameAndArgs;
                    }
                    this._helpCommandDescription = description || this._helpCommandDescription;
                }
                return this;
            }
        },
        {
            /**
   * @return {boolean}
   * @api private
   */ key: "_hasImplicitHelpCommand",
            value: function _hasImplicitHelpCommand() {
                if (this._addImplicitHelpCommand === undefined) {
                    return this.commands.length && !this._actionHandler && !this._findCommand('help');
                }
                return this._addImplicitHelpCommand;
            }
        },
        {
            /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */ key: "hook",
            value: function hook(event, listener) {
                var allowedValues = [
                    'preAction',
                    'postAction'
                ];
                if (!allowedValues.includes(event)) {
                    throw new Error("Unexpected value for event passed to hook : '".concat(event, "'.\nExpecting one of '").concat(allowedValues.join("', '"), "'"));
                }
                if (this._lifeCycleHooks[event]) {
                    this._lifeCycleHooks[event].push(listener);
                } else {
                    this._lifeCycleHooks[event] = [
                        listener
                    ];
                }
                return this;
            }
        },
        {
            /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */ key: "exitOverride",
            value: function exitOverride(fn) {
                if (fn) {
                    this._exitCallback = fn;
                } else {
                    this._exitCallback = function(err) {
                        if (err.code !== 'commander.executeSubCommandAsync') {
                            throw err;
                        } else {
                        // Async callback from spawn events, not useful to throw.
                        }
                    };
                }
                return this;
            }
        },
        {
            /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */ key: "_exit",
            value: function _exit(exitCode, code, message) {
                if (this._exitCallback) {
                    this._exitCallback(new CommanderError(exitCode, code, message));
                // Expecting this line is not reached.
                }
                process.exit(exitCode);
            }
        },
        {
            /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */ key: "action",
            value: function action(fn) {
                var _this = this;
                var listener = function(args) {
                    // The .action callback takes an extra parameter which is the command or options.
                    var expectedArgsCount = _this._args.length;
                    var actionArgs = args.slice(0, expectedArgsCount);
                    if (_this._storeOptionsAsProperties) {
                        actionArgs[expectedArgsCount] = _this; // backwards compatible "options"
                    } else {
                        actionArgs[expectedArgsCount] = _this.opts();
                    }
                    actionArgs.push(_this);
                    return fn.apply(_this, actionArgs);
                };
                this._actionHandler = listener;
                return this;
            }
        },
        {
            /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */ key: "createOption",
            value: function createOption(flags, description) {
                return new Option(flags, description);
            }
        },
        {
            /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */ key: "addOption",
            value: function addOption(option) {
                var _this = this;
                var oname = option.name();
                var name = option.attributeName();
                var defaultValue = option.defaultValue;
                // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value
                if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {
                    // when --no-foo we make sure default is true, unless a --foo option is already defined
                    if (option.negate) {
                        var positiveLongFlag = option.long.replace(/^--no-/, '--');
                        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
                    }
                    // preassign only if we have a default
                    if (defaultValue !== undefined) {
                        this.setOptionValueWithSource(name, defaultValue, 'default');
                    }
                }
                // register the option
                this.options.push(option);
                // handler for cli and env supplied values
                var handleOptionValue = function(val, invalidValueMessage, valueSource) {
                    // Note: using closure to access lots of lexical scoped variables.
                    var oldValue = _this.getOptionValue(name);
                    // custom processing
                    if (val !== null && option.parseArg) {
                        try {
                            val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);
                        } catch (err) {
                            if (err.code === 'commander.invalidArgument') {
                                var message = "".concat(invalidValueMessage, " ").concat(err.message);
                                _this._displayError(err.exitCode, err.code, message);
                            }
                            throw err;
                        }
                    } else if (val !== null && option.variadic) {
                        val = option._concatValue(val, oldValue);
                    }
                    // unassigned or boolean value
                    if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {
                        // if no value, negate false, and we have a default, then use it!
                        if (val == null) {
                            _this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
                        } else {
                            _this.setOptionValueWithSource(name, val, valueSource);
                        }
                    } else if (val !== null) {
                        // reassign
                        _this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
                    }
                };
                this.on('option:' + oname, function(val) {
                    var invalidValueMessage = "error: option '".concat(option.flags, "' argument '").concat(val, "' is invalid.");
                    handleOptionValue(val, invalidValueMessage, 'cli');
                });
                if (option.envVar) {
                    this.on('optionEnv:' + oname, function(val) {
                        var invalidValueMessage = "error: option '".concat(option.flags, "' value '").concat(val, "' from env '").concat(option.envVar, "' is invalid.");
                        handleOptionValue(val, invalidValueMessage, 'env');
                    });
                }
                return this;
            }
        },
        {
            /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */ key: "_optionEx",
            value: function _optionEx(config, flags, description, fn, defaultValue) {
                var option = this.createOption(flags, description);
                option.makeOptionMandatory(!!config.mandatory);
                if (typeof fn === 'function') {
                    option.default(defaultValue).argParser(fn);
                } else if (_instanceof(fn, RegExp)) {
                    // deprecated
                    var regex = fn;
                    fn = function(val, def) {
                        var m = regex.exec(val);
                        return m ? m[0] : def;
                    };
                    option.default(defaultValue).argParser(fn);
                } else {
                    option.default(fn);
                }
                return this.addOption(option);
            }
        },
        {
            /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string contains the short and/or long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   *     "-p, --pepper"
   *     "-p|--pepper"
   *     "-p --pepper"
   *
   * @example
   * // simple boolean defaulting to undefined
   * program.option('-p, --pepper', 'add pepper');
   *
   * program.pepper
   * // => undefined
   *
   * --pepper
   * program.pepper
   * // => true
   *
   * // simple boolean defaulting to true (unless non-negated option is also defined)
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [fn] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */ key: "option",
            value: function option(flags, description, fn, defaultValue) {
                return this._optionEx({}, flags, description, fn, defaultValue);
            }
        },
        {
            /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string} flags
  * @param {string} [description]
  * @param {Function|*} [fn] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */ key: "requiredOption",
            value: function requiredOption(flags, description, fn, defaultValue) {
                return this._optionEx({
                    mandatory: true
                }, flags, description, fn, defaultValue);
            }
        },
        {
            /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */ key: "combineFlagAndOptionalValue",
            value: function combineFlagAndOptionalValue() {
                var combine = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._combineFlagAndOptionalValue = !!combine;
                return this;
            }
        },
        {
            /**
   * Allow unknown options on the command line.
   *
   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
   * for unknown options.
   */ key: "allowUnknownOption",
            value: function allowUnknownOption() {
                var allowUnknown = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._allowUnknownOption = !!allowUnknown;
                return this;
            }
        },
        {
            /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
   * for excess arguments.
   */ key: "allowExcessArguments",
            value: function allowExcessArguments() {
                var allowExcess = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._allowExcessArguments = !!allowExcess;
                return this;
            }
        },
        {
            /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {Boolean} [positional=true]
   */ key: "enablePositionalOptions",
            value: function enablePositionalOptions() {
                var positional = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._enablePositionalOptions = !!positional;
                return this;
            }
        },
        {
            /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true]
   * for unknown options.
   */ key: "passThroughOptions",
            value: function passThroughOptions() {
                var passThrough = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._passThroughOptions = !!passThrough;
                if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
                    throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
                }
                return this;
            }
        },
        {
            /**
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean} [storeAsProperties=true]
    * @return {Command} `this` command for chaining
    */ key: "storeOptionsAsProperties",
            value: function storeOptionsAsProperties() {
                var storeAsProperties = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                this._storeOptionsAsProperties = !!storeAsProperties;
                if (this.options.length) {
                    throw new Error('call .storeOptionsAsProperties() before adding options');
                }
                return this;
            }
        },
        {
            /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {Object} value
   */ key: "getOptionValue",
            value: function getOptionValue(key) {
                if (this._storeOptionsAsProperties) {
                    return this[key];
                }
                return this._optionValues[key];
            }
        },
        {
            /**
   * Store option value.
   *
   * @param {string} key
   * @param {Object} value
   * @return {Command} `this` command for chaining
   */ key: "setOptionValue",
            value: function setOptionValue(key, value) {
                if (this._storeOptionsAsProperties) {
                    this[key] = value;
                } else {
                    this._optionValues[key] = value;
                }
                return this;
            }
        },
        {
            /**
   * Store option value and where the value came from.
    *
    * @param {string} key
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli
    * @return {Command} `this` command for chaining
    */ key: "setOptionValueWithSource",
            value: function setOptionValueWithSource(key, value, source) {
                this.setOptionValue(key, value);
                this._optionValueSources[key] = source;
                return this;
            }
        },
        {
            /**
    * Get source of option value.
    * Expected values are default | config | env | cli
    *
    * @param {string} key
    * @return {string}
    */ key: "getOptionValueSource",
            value: function getOptionValueSource(key) {
                return this._optionValueSources[key];
            }
        },
        {
            /**
   * Get user arguments implied or explicit arguments.
   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.
   *
   * @api private
   */ key: "_prepareUserArgs",
            value: function _prepareUserArgs(argv, parseOptions) {
                if (argv !== undefined && !Array.isArray(argv)) {
                    throw new Error('first parameter to parse must be array or undefined');
                }
                parseOptions = parseOptions || {};
                // Default to using process.argv
                if (argv === undefined) {
                    argv = process.argv;
                    // @ts-ignore: unknown property
                    if (process.versions && process.versions.electron) {
                        parseOptions.from = 'electron';
                    }
                }
                this.rawArgs = argv.slice();
                // make it a little easier for callers by supporting various argv conventions
                var userArgs;
                switch(parseOptions.from){
                    case undefined:
                    case 'node':
                        this._scriptPath = argv[1];
                        userArgs = argv.slice(2);
                        break;
                    case 'electron':
                        // @ts-ignore: unknown property
                        if (process.defaultApp) {
                            this._scriptPath = argv[1];
                            userArgs = argv.slice(2);
                        } else {
                            userArgs = argv.slice(1);
                        }
                        break;
                    case 'user':
                        userArgs = argv.slice(0);
                        break;
                    default:
                        throw new Error("unexpected parse option { from: '".concat(parseOptions.from, "' }"));
                }
                if (!this._scriptPath && require.main) {
                    this._scriptPath = require.main.filename;
                }
                // Guess name, used in usage in help.
                this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath));
                return userArgs;
            }
        },
        {
            /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */ key: "parse",
            value: function parse(argv, parseOptions) {
                var userArgs = this._prepareUserArgs(argv, parseOptions);
                this._parseCommand([], userArgs);
                return this;
            }
        },
        {
            key: "parseAsync",
            value: /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */ function parseAsync(argv, parseOptions) {
                var _this = this;
                return _async_to_generator(function() {
                    var userArgs;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                userArgs = _this._prepareUserArgs(argv, parseOptions);
                                return [
                                    4,
                                    _this._parseCommand([], userArgs)
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    2,
                                    _this
                                ];
                        }
                    });
                })();
            }
        },
        {
            /**
   * Execute a sub-command executable.
   *
   * @api private
   */ key: "_executeSubCommand",
            value: function _executeSubCommand(subcommand, args) {
                args = args.slice();
                var launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
                var sourceExt = [
                    '.js',
                    '.ts',
                    '.tsx',
                    '.mjs',
                    '.cjs'
                ];
                // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
                this._checkForMissingMandatoryOptions();
                // Want the entry script as the reference for command name and directory for searching for other files.
                var scriptPath = this._scriptPath;
                // Fallback in case not set, due to how Command created or called.
                if (!scriptPath && require.main) {
                    scriptPath = require.main.filename;
                }
                var baseDir;
                try {
                    var resolvedLink = fs.realpathSync(scriptPath);
                    baseDir = path.dirname(resolvedLink);
                } catch (e) {
                    baseDir = '.'; // dummy, probably not going to find executable!
                }
                // name of the subcommand, like `pm-install`
                var bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;
                if (subcommand._executableFile) {
                    bin = subcommand._executableFile;
                }
                var localBin = path.join(baseDir, bin);
                if (fs.existsSync(localBin)) {
                    // prefer local `./<bin>` to bin in the $PATH
                    bin = localBin;
                } else {
                    // Look for source files.
                    sourceExt.forEach(function(ext) {
                        if (fs.existsSync("".concat(localBin).concat(ext))) {
                            bin = "".concat(localBin).concat(ext);
                        }
                    });
                }
                launchWithNode = sourceExt.includes(path.extname(bin));
                var proc;
                if (process.platform !== 'win32') {
                    if (launchWithNode) {
                        args.unshift(bin);
                        // add executable arguments to spawn
                        args = incrementNodeInspectorPort(process.execArgv).concat(args);
                        proc = childProcess.spawn(process.argv[0], args, {
                            stdio: 'inherit'
                        });
                    } else {
                        proc = childProcess.spawn(bin, args, {
                            stdio: 'inherit'
                        });
                    }
                } else {
                    args.unshift(bin);
                    // add executable arguments to spawn
                    args = incrementNodeInspectorPort(process.execArgv).concat(args);
                    proc = childProcess.spawn(process.execPath, args, {
                        stdio: 'inherit'
                    });
                }
                var signals = [
                    'SIGUSR1',
                    'SIGUSR2',
                    'SIGTERM',
                    'SIGINT',
                    'SIGHUP'
                ];
                signals.forEach(function(signal) {
                    // @ts-ignore
                    process.on(signal, function() {
                        if (proc.killed === false && proc.exitCode === null) {
                            proc.kill(signal);
                        }
                    });
                });
                // By default terminate process when spawned process terminates.
                // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
                var exitCallback = this._exitCallback;
                if (!exitCallback) {
                    proc.on('close', process.exit.bind(process));
                } else {
                    proc.on('close', function() {
                        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
                    });
                }
                proc.on('error', function(err) {
                    // @ts-ignore
                    if (err.code === 'ENOENT') {
                        var executableMissing = "'".concat(bin, "' does not exist\n - if '").concat(subcommand._name, "' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name");
                        throw new Error(executableMissing);
                    // @ts-ignore
                    } else if (err.code === 'EACCES') {
                        throw new Error("'".concat(bin, "' not executable"));
                    }
                    if (!exitCallback) {
                        process.exit(1);
                    } else {
                        var wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
                        wrappedError.nestedError = err;
                        exitCallback(wrappedError);
                    }
                });
                // Store the reference to the child process
                this.runningCommand = proc;
            }
        },
        {
            /**
   * @api private
   */ key: "_dispatchSubcommand",
            value: function _dispatchSubcommand(commandName, operands, unknown) {
                var subCommand = this._findCommand(commandName);
                if (!subCommand) this.help({
                    error: true
                });
                if (subCommand._executableHandler) {
                    this._executeSubCommand(subCommand, operands.concat(unknown));
                } else {
                    return subCommand._parseCommand(operands, unknown);
                }
            }
        },
        {
            /**
   * Check this.args against expected this._args.
   *
   * @api private
   */ key: "_checkNumberOfArguments",
            value: function _checkNumberOfArguments() {
                var _this = this;
                // too few
                this._args.forEach(function(arg, i) {
                    if (arg.required && _this.args[i] == null) {
                        _this.missingArgument(arg.name());
                    }
                });
                // too many
                if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
                    return;
                }
                if (this.args.length > this._args.length) {
                    this._excessArguments(this.args);
                }
            }
        },
        {
            /**
   * Process this.args using this._args and save as this.processedArgs!
   *
   * @api private
   */ key: "_processArguments",
            value: function _processArguments() {
                var _this = this;
                var myParseArg = function(argument, value, previous) {
                    // Extra processing for nice error message on parsing failure.
                    var parsedValue = value;
                    if (value !== null && argument.parseArg) {
                        try {
                            parsedValue = argument.parseArg(value, previous);
                        } catch (err) {
                            if (err.code === 'commander.invalidArgument') {
                                var message = "error: command-argument value '".concat(value, "' is invalid for argument '").concat(argument.name(), "'. ").concat(err.message);
                                _this._displayError(err.exitCode, err.code, message);
                            }
                            throw err;
                        }
                    }
                    return parsedValue;
                };
                this._checkNumberOfArguments();
                var processedArgs = [];
                this._args.forEach(function(declaredArg, index) {
                    var value = declaredArg.defaultValue;
                    if (declaredArg.variadic) {
                        // Collect together remaining arguments for passing together as an array.
                        if (index < _this.args.length) {
                            value = _this.args.slice(index);
                            if (declaredArg.parseArg) {
                                value = value.reduce(function(processed, v) {
                                    return myParseArg(declaredArg, v, processed);
                                }, declaredArg.defaultValue);
                            }
                        } else if (value === undefined) {
                            value = [];
                        }
                    } else if (index < _this.args.length) {
                        value = _this.args[index];
                        if (declaredArg.parseArg) {
                            value = myParseArg(declaredArg, value, declaredArg.defaultValue);
                        }
                    }
                    processedArgs[index] = value;
                });
                this.processedArgs = processedArgs;
            }
        },
        {
            /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */ key: "_chainOrCall",
            value: function _chainOrCall(promise, fn) {
                // thenable
                if (promise && promise.then && typeof promise.then === 'function') {
                    // already have a promise, chain callback
                    return promise.then(function() {
                        return fn();
                    });
                }
                // callback might return a promise
                return fn();
            }
        },
        {
            /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */ key: "_chainOrCallHooks",
            value: function _chainOrCallHooks(promise, event) {
                var _this = this;
                var result = promise;
                var hooks = [];
                getCommandAndParents(this).reverse().filter(function(cmd) {
                    return cmd._lifeCycleHooks[event] !== undefined;
                }).forEach(function(hookedCommand) {
                    hookedCommand._lifeCycleHooks[event].forEach(function(callback) {
                        hooks.push({
                            hookedCommand: hookedCommand,
                            callback: callback
                        });
                    });
                });
                if (event === 'postAction') {
                    hooks.reverse();
                }
                hooks.forEach(function(hookDetail) {
                    result = _this._chainOrCall(result, function() {
                        return hookDetail.callback(hookDetail.hookedCommand, _this);
                    });
                });
                return result;
            }
        },
        {
            /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */ key: "_parseCommand",
            value: function _parseCommand(operands, unknown) {
                var _this = this;
                var parsed = this.parseOptions(unknown);
                this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
                operands = operands.concat(parsed.operands);
                unknown = parsed.unknown;
                this.args = operands.concat(unknown);
                if (operands && this._findCommand(operands[0])) {
                    return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
                }
                if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
                    if (operands.length === 1) {
                        this.help();
                    }
                    return this._dispatchSubcommand(operands[1], [], [
                        this._helpLongFlag
                    ]);
                }
                if (this._defaultCommandName) {
                    outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
                    return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
                }
                if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
                    // probably missing subcommand and no handler, user needs help (and exit)
                    this.help({
                        error: true
                    });
                }
                outputHelpIfRequested(this, parsed.unknown);
                this._checkForMissingMandatoryOptions();
                // We do not always call this check to avoid masking a "better" error, like unknown command.
                var checkForUnknownOptions = function() {
                    if (parsed.unknown.length > 0) {
                        _this.unknownOption(parsed.unknown[0]);
                    }
                };
                var commandEvent = "command:".concat(this.name());
                if (this._actionHandler) {
                    checkForUnknownOptions();
                    this._processArguments();
                    var actionResult;
                    actionResult = this._chainOrCallHooks(actionResult, 'preAction');
                    actionResult = this._chainOrCall(actionResult, function() {
                        return _this._actionHandler(_this.processedArgs);
                    });
                    if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy
                    actionResult = this._chainOrCallHooks(actionResult, 'postAction');
                    return actionResult;
                }
                if (this.parent && this.parent.listenerCount(commandEvent)) {
                    checkForUnknownOptions();
                    this._processArguments();
                    this.parent.emit(commandEvent, operands, unknown); // legacy
                } else if (operands.length) {
                    if (this._findCommand('*')) {
                        return this._dispatchSubcommand('*', operands, unknown);
                    }
                    if (this.listenerCount('command:*')) {
                        // skip option check, emit event for possible misspelling suggestion
                        this.emit('command:*', operands, unknown);
                    } else if (this.commands.length) {
                        this.unknownCommand();
                    } else {
                        checkForUnknownOptions();
                        this._processArguments();
                    }
                } else if (this.commands.length) {
                    checkForUnknownOptions();
                    // This command has subcommands and nothing hooked up at this level, so display help (and exit).
                    this.help({
                        error: true
                    });
                } else {
                    checkForUnknownOptions();
                    this._processArguments();
                // fall through for caller to handle after calling .parse()
                }
            }
        },
        {
            /**
   * Find matching command.
   *
   * @api private
   */ key: "_findCommand",
            value: function _findCommand(name) {
                if (!name) return undefined;
                return this.commands.find(function(cmd) {
                    return cmd._name === name || cmd._aliases.includes(name);
                });
            }
        },
        {
            /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */ key: "_findOption",
            value: function _findOption(arg) {
                return this.options.find(function(option) {
                    return option.is(arg);
                });
            }
        },
        {
            /**
   * Display an error message if a mandatory option does not have a value.
   * Lazy calling after checking for help flags from leaf subcommand.
   *
   * @api private
   */ key: "_checkForMissingMandatoryOptions",
            value: function _checkForMissingMandatoryOptions() {
                var _loop = function(cmd) {
                    cmd.options.forEach(function(anOption) {
                        if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
                            cmd.missingMandatoryOptionValue(anOption);
                        }
                    });
                };
                // Walk up hierarchy so can call in subcommand after checking for displaying help.
                for(var cmd = this; cmd; cmd = cmd.parent)_loop(cmd);
            }
        },
        {
            /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {String[]} argv
   * @return {{operands: String[], unknown: String[]}}
   */ key: "parseOptions",
            value: function parseOptions(argv) {
                var operands = []; // operands, not options or values
                var unknown = []; // first unknown option and remaining unknown args
                var dest = operands;
                var args = argv.slice();
                function maybeOption(arg) {
                    return arg.length > 1 && arg[0] === '-';
                }
                // parse options
                var activeVariadicOption = null;
                while(args.length){
                    var arg = args.shift();
                    // literal
                    if (arg === '--') {
                        var _dest;
                        if (dest === unknown) dest.push(arg);
                        (_dest = dest).push.apply(_dest, _to_consumable_array(args));
                        break;
                    }
                    if (activeVariadicOption && !maybeOption(arg)) {
                        this.emit("option:".concat(activeVariadicOption.name()), arg);
                        continue;
                    }
                    activeVariadicOption = null;
                    if (maybeOption(arg)) {
                        var option = this._findOption(arg);
                        // recognised option, call listener to assign value with possible custom processing
                        if (option) {
                            if (option.required) {
                                var value = args.shift();
                                if (value === undefined) this.optionMissingArgument(option);
                                this.emit("option:".concat(option.name()), value);
                            } else if (option.optional) {
                                var value1 = null;
                                // historical behaviour is optional value is following arg unless an option
                                if (args.length > 0 && !maybeOption(args[0])) {
                                    value1 = args.shift();
                                }
                                this.emit("option:".concat(option.name()), value1);
                            } else {
                                this.emit("option:".concat(option.name()));
                            }
                            activeVariadicOption = option.variadic ? option : null;
                            continue;
                        }
                    }
                    // Look for combo options following single dash, eat first one if known.
                    if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
                        var option1 = this._findOption("-".concat(arg[1]));
                        if (option1) {
                            if (option1.required || option1.optional && this._combineFlagAndOptionalValue) {
                                // option with value following in same argument
                                this.emit("option:".concat(option1.name()), arg.slice(2));
                            } else {
                                // boolean option, emit and put back remainder of arg for further processing
                                this.emit("option:".concat(option1.name()));
                                args.unshift("-".concat(arg.slice(2)));
                            }
                            continue;
                        }
                    }
                    // Look for known long flag with value, like --foo=bar
                    if (/^--[^=]+=/.test(arg)) {
                        var index = arg.indexOf('=');
                        var option2 = this._findOption(arg.slice(0, index));
                        if (option2 && (option2.required || option2.optional)) {
                            this.emit("option:".concat(option2.name()), arg.slice(index + 1));
                            continue;
                        }
                    }
                    // Not a recognised option by this command.
                    // Might be a command-argument, or subcommand option, or unknown option, or help command or option.
                    // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
                    if (maybeOption(arg)) {
                        dest = unknown;
                    }
                    // If using positionalOptions, stop processing our options at subcommand.
                    if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
                        if (this._findCommand(arg)) {
                            var _unknown;
                            operands.push(arg);
                            if (args.length > 0) (_unknown = unknown).push.apply(_unknown, _to_consumable_array(args));
                            break;
                        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
                            var _operands;
                            operands.push(arg);
                            if (args.length > 0) (_operands = operands).push.apply(_operands, _to_consumable_array(args));
                            break;
                        } else if (this._defaultCommandName) {
                            var _unknown1;
                            unknown.push(arg);
                            if (args.length > 0) (_unknown1 = unknown).push.apply(_unknown1, _to_consumable_array(args));
                            break;
                        }
                    }
                    // If using passThroughOptions, stop processing options at first command-argument.
                    if (this._passThroughOptions) {
                        var _dest1;
                        dest.push(arg);
                        if (args.length > 0) (_dest1 = dest).push.apply(_dest1, _to_consumable_array(args));
                        break;
                    }
                    // add arg
                    dest.push(arg);
                }
                return {
                    operands: operands,
                    unknown: unknown
                };
            }
        },
        {
            /**
   * Return an object containing options as key-value pairs
   *
   * @return {Object}
   */ key: "opts",
            value: function opts() {
                if (this._storeOptionsAsProperties) {
                    // Preserve original behaviour so backwards compatible when still using properties
                    var result = {};
                    var len = this.options.length;
                    for(var i = 0; i < len; i++){
                        var key = this.options[i].attributeName();
                        result[key] = key === this._versionOptionName ? this._version : this[key];
                    }
                    return result;
                }
                return this._optionValues;
            }
        },
        {
            /**
   * Internal bottleneck for handling of parsing errors.
   *
   * @api private
   */ key: "_displayError",
            value: function _displayError(exitCode, code, message) {
                this._outputConfiguration.outputError("".concat(message, "\n"), this._outputConfiguration.writeErr);
                if (typeof this._showHelpAfterError === 'string') {
                    this._outputConfiguration.writeErr("".concat(this._showHelpAfterError, "\n"));
                } else if (this._showHelpAfterError) {
                    this._outputConfiguration.writeErr('\n');
                    this.outputHelp({
                        error: true
                    });
                }
                this._exit(exitCode, code, message);
            }
        },
        {
            /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */ key: "_parseOptionsEnv",
            value: function _parseOptionsEnv() {
                var _this = this;
                this.options.forEach(function(option) {
                    if (option.envVar && option.envVar in process.env) {
                        var optionKey = option.attributeName();
                        // Priority check. Do not overwrite cli or options from unknown source (client-code).
                        if (_this.getOptionValue(optionKey) === undefined || [
                            'default',
                            'config',
                            'env'
                        ].includes(_this.getOptionValueSource(optionKey))) {
                            if (option.required || option.optional) {
                                // keep very simple, optional always takes value
                                _this.emit("optionEnv:".concat(option.name()), process.env[option.envVar]);
                            } else {
                                // keep very simple, only care that envVar defined and not the value
                                _this.emit("optionEnv:".concat(option.name()));
                            }
                        }
                    }
                });
            }
        },
        {
            /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */ key: "missingArgument",
            value: function missingArgument(name) {
                var message = "error: missing required argument '".concat(name, "'");
                this._displayError(1, 'commander.missingArgument', message);
            }
        },
        {
            /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private
   */ key: "optionMissingArgument",
            value: function optionMissingArgument(option) {
                var message = "error: option '".concat(option.flags, "' argument missing");
                this._displayError(1, 'commander.optionMissingArgument', message);
            }
        },
        {
            /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private
   */ key: "missingMandatoryOptionValue",
            value: function missingMandatoryOptionValue(option) {
                var message = "error: required option '".concat(option.flags, "' not specified");
                this._displayError(1, 'commander.missingMandatoryOptionValue', message);
            }
        },
        {
            /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @api private
   */ key: "unknownOption",
            value: function unknownOption(flag) {
                if (this._allowUnknownOption) return;
                var suggestion = '';
                if (flag.startsWith('--') && this._showSuggestionAfterError) {
                    // Looping to pick up the global options too
                    var candidateFlags = [];
                    var command = this;
                    do {
                        var moreFlags = command.createHelp().visibleOptions(command).filter(function(option) {
                            return option.long;
                        }).map(function(option) {
                            return option.long;
                        });
                        candidateFlags = candidateFlags.concat(moreFlags);
                        command = command.parent;
                    }while (command && !command._enablePositionalOptions);
                    suggestion = suggestSimilar(flag, candidateFlags);
                }
                var message = "error: unknown option '".concat(flag, "'").concat(suggestion);
                this._displayError(1, 'commander.unknownOption', message);
            }
        },
        {
            /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @api private
   */ key: "_excessArguments",
            value: function _excessArguments(receivedArgs) {
                if (this._allowExcessArguments) return;
                var expected = this._args.length;
                var s = expected === 1 ? '' : 's';
                var forSubcommand = this.parent ? " for '".concat(this.name(), "'") : '';
                var message = "error: too many arguments".concat(forSubcommand, ". Expected ").concat(expected, " argument").concat(s, " but got ").concat(receivedArgs.length, ".");
                this._displayError(1, 'commander.excessArguments', message);
            }
        },
        {
            /**
   * Unknown command.
   *
   * @api private
   */ key: "unknownCommand",
            value: function unknownCommand() {
                var unknownName = this.args[0];
                var suggestion = '';
                if (this._showSuggestionAfterError) {
                    var candidateNames = [];
                    this.createHelp().visibleCommands(this).forEach(function(command) {
                        candidateNames.push(command.name());
                        // just visible alias
                        if (command.alias()) candidateNames.push(command.alias());
                    });
                    suggestion = suggestSimilar(unknownName, candidateNames);
                }
                var message = "error: unknown command '".concat(unknownName, "'").concat(suggestion);
                this._displayError(1, 'commander.unknownCommand', message);
            }
        },
        {
            /**
   * Set the program version to `str`.
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * You can optionally supply the  flags and description to override the defaults.
   *
   * @param {string} str
   * @param {string} [flags]
   * @param {string} [description]
   * @return {this | string} `this` command for chaining, or version string if no arguments
   */ key: "version",
            value: function version(str, flags, description) {
                var _this = this;
                if (str === undefined) return this._version;
                this._version = str;
                flags = flags || '-V, --version';
                description = description || 'output the version number';
                var versionOption = this.createOption(flags, description);
                this._versionOptionName = versionOption.attributeName();
                this.options.push(versionOption);
                this.on('option:' + versionOption.name(), function() {
                    _this._outputConfiguration.writeOut("".concat(str, "\n"));
                    _this._exit(0, 'commander.version', str);
                });
                return this;
            }
        },
        {
            /**
   * Set the description to `str`.
   *
   * @param {string} [str]
   * @param {Object} [argsDescription]
   * @return {string|Command}
   */ key: "description",
            value: function description(str, argsDescription) {
                if (str === undefined && argsDescription === undefined) return this._description;
                this._description = str;
                if (argsDescription) {
                    this._argsDescription = argsDescription;
                }
                return this;
            }
        },
        {
            /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {string|Command}
   */ key: "alias",
            value: function alias(alias) {
                if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility
                /** @type {Command} */ var command = this;
                if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
                    // assume adding alias for last added executable subcommand, rather than this
                    command = this.commands[this.commands.length - 1];
                }
                if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');
                command._aliases.push(alias);
                return this;
            }
        },
        {
            /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {string[]|Command}
   */ key: "aliases",
            value: function aliases(aliases) {
                var _this = this;
                // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
                if (aliases === undefined) return this._aliases;
                aliases.forEach(function(alias) {
                    return _this.alias(alias);
                });
                return this;
            }
        },
        {
            /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {String|Command}
   */ key: "usage",
            value: function usage(str) {
                if (str === undefined) {
                    if (this._usage) return this._usage;
                    var args = this._args.map(function(arg) {
                        return humanReadableArgName(arg);
                    });
                    return [].concat(this.options.length || this._hasHelpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this._args.length ? args : []).join(' ');
                }
                this._usage = str;
                return this;
            }
        },
        {
            /**
   * Get or set the name of the command
   *
   * @param {string} [str]
   * @return {string|Command}
   */ key: "name",
            value: function name(str) {
                if (str === undefined) return this._name;
                this._name = str;
                return this;
            }
        },
        {
            /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */ key: "helpInformation",
            value: function helpInformation(contextOptions) {
                var helper = this.createHelp();
                if (helper.helpWidth === undefined) {
                    helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
                }
                return helper.formatHelp(this, helper);
            }
        },
        {
            /**
   * @api private
   */ key: "_getHelpContext",
            value: function _getHelpContext(contextOptions) {
                var _this = this;
                contextOptions = contextOptions || {};
                var context = {
                    error: !!contextOptions.error
                };
                var write;
                if (context.error) {
                    write = function(arg) {
                        return _this._outputConfiguration.writeErr(arg);
                    };
                } else {
                    write = function(arg) {
                        return _this._outputConfiguration.writeOut(arg);
                    };
                }
                context.write = contextOptions.write || write;
                context.command = this;
                return context;
            }
        },
        {
            /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */ key: "outputHelp",
            value: function outputHelp(contextOptions) {
                var deprecatedCallback;
                if (typeof contextOptions === 'function') {
                    deprecatedCallback = contextOptions;
                    contextOptions = undefined;
                }
                var context = this._getHelpContext(contextOptions);
                getCommandAndParents(this).reverse().forEach(function(command) {
                    return command.emit('beforeAllHelp', context);
                });
                this.emit('beforeHelp', context);
                var helpInformation = this.helpInformation(context);
                if (deprecatedCallback) {
                    helpInformation = deprecatedCallback(helpInformation);
                    if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
                        throw new Error('outputHelp callback must return a string or a Buffer');
                    }
                }
                context.write(helpInformation);
                this.emit(this._helpLongFlag); // deprecated
                this.emit('afterHelp', context);
                getCommandAndParents(this).forEach(function(command) {
                    return command.emit('afterAllHelp', context);
                });
            }
        },
        {
            /**
   * You can pass in flags and a description to override the help
   * flags and help description for your command. Pass in false to
   * disable the built-in help option.
   *
   * @param {string | boolean} [flags]
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */ key: "helpOption",
            value: function helpOption(flags, description) {
                if (typeof flags === 'boolean') {
                    this._hasHelpOption = flags;
                    return this;
                }
                this._helpFlags = flags || this._helpFlags;
                this._helpDescription = description || this._helpDescription;
                var helpFlags = splitOptionFlags(this._helpFlags);
                this._helpShortFlag = helpFlags.shortFlag;
                this._helpLongFlag = helpFlags.longFlag;
                return this;
            }
        },
        {
            /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */ key: "help",
            value: function help(contextOptions) {
                this.outputHelp(contextOptions);
                var exitCode = process.exitCode || 0;
                if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
                    exitCode = 1;
                }
                // message: do not have all displayed text available so only passing placeholder.
                this._exit(exitCode, 'commander.help', '(outputHelp)');
            }
        },
        {
            /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {string | Function} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */ key: "addHelpText",
            value: function addHelpText(position, text) {
                var allowedValues = [
                    'beforeAll',
                    'before',
                    'after',
                    'afterAll'
                ];
                if (!allowedValues.includes(position)) {
                    throw new Error("Unexpected value for position to addHelpText.\nExpecting one of '".concat(allowedValues.join("', '"), "'"));
                }
                var helpEvent = "".concat(position, "Help");
                this.on(helpEvent, function(context) {
                    var helpStr;
                    if (typeof text === 'function') {
                        helpStr = text({
                            error: context.error,
                            command: context.command
                        });
                    } else {
                        helpStr = text;
                    }
                    // Ignore falsy value when nothing to output.
                    if (helpStr) {
                        context.write("".concat(helpStr, "\n"));
                    }
                });
                return this;
            }
        }
    ]);
    return Command;
}(EventEmitter);
;
/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */ function outputHelpIfRequested(cmd, args) {
    var helpOption = cmd._hasHelpOption && args.find(function(arg) {
        return arg === cmd._helpLongFlag || arg === cmd._helpShortFlag;
    });
    if (helpOption) {
        cmd.outputHelp();
        // (Do not have all displayed text available so only passing placeholder.)
        cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
}
/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */ function incrementNodeInspectorPort(args) {
    // Testing for these options:
    //  --inspect[=[host:]port]
    //  --inspect-brk[=[host:]port]
    //  --inspect-port=[host:]port
    return args.map(function(arg) {
        if (!arg.startsWith('--inspect')) {
            return arg;
        }
        var debugOption;
        var debugHost = '127.0.0.1';
        var debugPort = '9229';
        var match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
            // e.g. --inspect
            debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
            debugOption = match[1];
            if (/^\d+$/.test(match[3])) {
                // e.g. --inspect=1234
                debugPort = match[3];
            } else {
                // e.g. --inspect=localhost
                debugHost = match[3];
            }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
            // e.g. --inspect=localhost:1234
            debugOption = match[1];
            debugHost = match[3];
            debugPort = match[4];
        }
        if (debugOption && debugPort !== '0') {
            return "".concat(debugOption, "=").concat(debugHost, ":").concat(parseInt(debugPort) + 1);
        }
        return arg;
    });
}
/**
 * @param {Command} startCommand
 * @returns {Command[]}
 * @api private
 */ function getCommandAndParents(startCommand) {
    var result = [];
    for(var command = startCommand; command; command = command.parent){
        result.push(command);
    }
    return result;
}
exports.Command = Command;
