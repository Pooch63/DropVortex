function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
var path = require('path');
var COLON = isWindows ? ';' : ':';
var isexe = require('isexe');
var getNotFoundError = function(cmd) {
    return Object.assign(new Error("not found: ".concat(cmd)), {
        code: 'ENOENT'
    });
};
var getPathInfo = function(cmd, opt) {
    var colon = opt.colon || COLON;
    // If it has a slash, then we don't bother searching the pathenv.
    // just check the file itself, and that's it.
    var pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
        ''
    ] : // windows always checks the cwd first
    _to_consumable_array(isWindows ? [
        process.cwd()
    ] : []).concat(_to_consumable_array((opt.path || process.env.PATH || /* istanbul ignore next: very unusual */ '').split(colon)));
    var pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
    var pathExt = isWindows ? pathExtExe.split(colon) : [
        ''
    ];
    if (isWindows) {
        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
    }
    return {
        pathEnv: pathEnv,
        pathExt: pathExt,
        pathExtExe: pathExtExe
    };
};
var which = function(cmd, opt, cb) {
    if (typeof opt === 'function') {
        cb = opt;
        opt = {};
    }
    if (!opt) opt = {};
    var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe;
    var found = [];
    var step = function(i) {
        return new Promise(function(resolve, reject) {
            if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            var ppRaw = pathEnv[i];
            var pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            var pCmd = path.join(pathPart, cmd);
            var p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
        });
    };
    var subStep = function(p, i, ii) {
        return new Promise(function(resolve, reject) {
            if (ii === pathExt.length) return resolve(step(i + 1));
            var ext = pathExt[ii];
            isexe(p + ext, {
                pathExt: pathExtExe
            }, function(er, is) {
                if (!er && is) {
                    if (opt.all) found.push(p + ext);
                    else return resolve(p + ext);
                }
                return resolve(subStep(p, i, ii + 1));
            });
        });
    };
    return cb ? step(0).then(function(res) {
        return cb(null, res);
    }, cb) : step(0);
};
var whichSync = function(cmd, opt) {
    opt = opt || {};
    var _getPathInfo = getPathInfo(cmd, opt), pathEnv = _getPathInfo.pathEnv, pathExt = _getPathInfo.pathExt, pathExtExe = _getPathInfo.pathExtExe;
    var found = [];
    for(var i = 0; i < pathEnv.length; i++){
        var ppRaw = pathEnv[i];
        var pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        var pCmd = path.join(pathPart, cmd);
        var p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for(var j = 0; j < pathExt.length; j++){
            var cur = p + pathExt[j];
            try {
                var is = isexe.sync(cur, {
                    pathExt: pathExtExe
                });
                if (is) {
                    if (opt.all) found.push(cur);
                    else return cur;
                }
            } catch (ex) {}
        }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
};
module.exports = which;
which.sync = whichSync;
